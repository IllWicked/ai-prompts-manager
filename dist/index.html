<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Prompts Manager</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- ДОБАВЛЕНИЕ FAVICON: Иконка Claude AI (КОЛЬЦО С ПРОЗРАЧНОЙ СЕРЕДИНОЙ) -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' fill='%23d97757'><path fill-rule='evenodd' d='M50 0C22.3857 0 0 22.3857 0 50C0 77.6143 22.3857 100 50 100C77.6143 100 100 77.6143 100 50C100 22.3857 77.6143 0 50 0ZM50 21.5C65.6357 21.5 78.5 34.3643 78.5 50C78.5 65.6357 65.6357 78.5 50 78.5C34.3643 78.5 21.5 65.6357 21.5 50C21.5 34.3643 34.3643 21.5 50 21.5Z'/></svg>">

    <style>
        /* Определение пользовательских цветов на основе #d97757 */
        :root {
            --claude-primary: #d97757;
            --claude-light: #fcf0ed; /* Очень светлый фон для инструкций */
            --claude-code: #f4e7e3;  /* Чуть темнее для фона <code> */
            --claude-shadow: rgba(217, 119, 87, 0.4); /* Для тени при наведении */
            
            /* Светлая тема (по умолчанию) */
            --bg-primary: #F5F5F7;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f9fafb;
            --bg-header: rgba(245, 245, 247, 0.9);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --text-muted: #9ca3af;
            --border-color: rgba(0, 0, 0, 0.05);
            --border-light: #e5e7eb;
        }
        
        /* Тёмная тема */
        .dark {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --bg-header: rgba(26, 26, 26, 0.9);
            --text-primary: #f3f4f6;
            --text-secondary: #d1d5db;
            --text-muted: #6b7280;
            --border-color: rgba(255, 255, 255, 0.1);
            --border-light: #404040;
            --claude-light: #3d2a24;
            --claude-code: #4a3530;
        }

        /* Пользовательские классы Tailwind для интеграции нового цвета */
        .claude-accent { color: var(--claude-primary); }
        .bg-claude-accent { background-color: var(--claude-primary); }
        .text-claude-accent { color: var(--claude-primary); }
        .ring-claude-accent { --tw-ring-color: var(--claude-primary); }
        .shadow-claude { box-shadow: 0 4px 12px var(--claude-shadow); }
        .bg-claude-light { background-color: var(--claude-light); }
        .bg-claude-code { background-color: var(--claude-code); }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        .prompt-card {
            border: 1px solid var(--border-color);
            transition: box-shadow 0.2s ease, background-color 0.3s;
            background-color: var(--bg-secondary);
        }
        .dark .prompt-card {
            border-color: var(--border-light);
        }
        .prompt-card.editing {
            box-shadow: 0 0 12px 2px var(--claude-shadow);
        }
        .textarea-content.editing-mode {
            background-color: var(--bg-tertiary);
        }
        /* Убираем белую полосу снизу при редактировании */
        .prompt-card.editing {
            background-color: var(--bg-tertiary);
        }
        
        /* Текстовое поле с динамической высотой и ограничениями */
        .textarea-content {
            min-height: 175px; /* Минимальная высота */
            max-height: 350px; /* Максимальная высота */
            overflow-y: auto; 
            resize: none; 
            padding-bottom: 1.5rem !important;
            user-select: text;
            -webkit-user-select: text;
        }

        /* Стилизованные скроллбары для textarea */
        /* Скрываем нативные скроллбары */
        .textarea-content {
            overflow-y: scroll;
            overflow-x: hidden;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        .textarea-content::-webkit-scrollbar {
            display: none; /* Chrome/Safari/Opera */
        }
        
        /* Контейнер textarea с кастомным скроллбаром */
        .textarea-wrapper {
            position: relative;
        }
        
        /* Кастомный скроллбар для textarea - всегда видимый */
        .custom-scrollbar {
            position: absolute;
            right: 4px;
            top: 4px;
            bottom: 10px;
            width: 6px;
            background: transparent;
            border-radius: 3px;
            transition: width 0.2s ease;
            z-index: 10;
        }
        
        .custom-scrollbar.active {
            width: 8px;
        }
        
        .custom-scrollbar-thumb {
            position: absolute;
            right: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s ease;
        }
        
        .custom-scrollbar-thumb:hover,
        .custom-scrollbar-thumb.dragging {
            background: rgba(0, 0, 0, 0.35);
        }
        
        /* Основной контейнер - скрываем нативный скроллбар */
        #scroll-container {
            overflow-y: scroll;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        #scroll-container::-webkit-scrollbar {
            display: none;
        }
        
        /* Кастомный скроллбар для основного контейнера - под шапкой */
        .main-scrollbar {
            position: fixed;
            right: 4px;
            top: 68px; /* Высота шапки */
            bottom: 4px;
            width: 6px;
            background: transparent;
            transition: width 0.2s ease;
            z-index: 100;
        }
        
        .main-scrollbar.active {
            width: 8px;
        }
        
        .main-scrollbar-thumb {
            position: absolute;
            right: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s ease;
        }
        
        .main-scrollbar-thumb:hover,
        .main-scrollbar-thumb.dragging {
            background: rgba(0, 0, 0, 0.35);
        }

        /* Стиль кнопки копирования */
        .copy-button,
        .edit-button {
            cursor: pointer;
            padding: 0.5rem; 
            border-radius: 0.5rem;
        }
        .copy-button:hover,
        .edit-button:hover {
            background-color: #e5e7eb; /* Светло-серый при наведении */
        }
        
        .header-controls {
            display: flex;
            gap: 0.5rem; 
        }

        .toast {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            transform: translateY(20px) translateX(-50%);
        }
        .toast.show {
            visibility: visible;
            opacity: 1;
            transform: translateY(0) translateX(-50%);
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-weight: 500;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-top: 4px solid var(--claude-primary); /* Использование нового цвета */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Стиль кнопки-разделителя */
        .chat-button {
            transition: box-shadow 0.25s ease, transform 0.1s ease, filter 0.1s ease;
            cursor: pointer;
        }
        .chat-button:hover {
            /* Мягкое растушёванное свечение - эффект лампочки */
            box-shadow: 0 0 8px rgba(217, 119, 87, 0.5), 0 0 16px rgba(217, 119, 87, 0.35), 0 0 24px rgba(217, 119, 87, 0.2);
        }
        .chat-button:active {
            /* При нажатии - кнопка слегка тускнеет и чуть уменьшается */
            transform: scale(0.97);
            filter: brightness(0.9);
            box-shadow: 0 0 8px rgba(217, 119, 87, 0.4), 0 0 15px rgba(217, 119, 87, 0.25);
        }
        
        /* Кнопка добавления блока */
        .add-block-btn {
            transition: box-shadow 0.25s ease, transform 0.1s ease, filter 0.1s ease;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .add-block-btn:hover {
            box-shadow: 0 0 10px rgba(217, 119, 87, 0.5), 0 0 20px rgba(217, 119, 87, 0.35), 0 0 30px rgba(217, 119, 87, 0.2);
            transform: scale(1.05);
        }
        .add-block-btn:active {
            transform: scale(0.95);
            filter: brightness(0.9);
            box-shadow: 0 0 8px rgba(217, 119, 87, 0.4), 0 0 15px rgba(217, 119, 87, 0.25);
        }
        
        /* Кнопка Готово */
        .exit-edit-btn {
            transition: box-shadow 0.25s ease, transform 0.1s ease, filter 0.1s ease;
            cursor: pointer;
        }
        .exit-edit-btn:hover {
            box-shadow: 0 0 6px rgba(217, 119, 87, 0.5), 0 0 12px rgba(217, 119, 87, 0.3);
        }
        .exit-edit-btn:active {
            transform: scale(0.97);
            filter: brightness(0.9);
        }
        
        /* Меню добавления элемента */
        .add-menu {
            min-width: 150px;
        }
        .dark .add-menu {
            background: var(--bg-secondary);
            border-color: #3d3d3d;
        }
        .dark .add-menu-item {
            color: #e5e5e5;
        }
        .dark .add-menu-item:hover {
            background: #3d3d3d;
        }

        /* Универсальный акцентный цвет для иконки и нумерации */
        .claude-icon {
            color: var(--claude-primary); /* Использование нового цвета */
        }
        
        /* Кликабельная иконка в хедере */
        .update-check-btn {
            padding: 4px;
            cursor: pointer;
            background: transparent;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .update-check-btn .claude-icon {
            transition: filter 0.25s ease;
        }
        /* Hover - статичная лёгкая тень-окантовка */
        .update-check-btn:hover .claude-icon {
            filter: drop-shadow(0 0 2px rgba(217, 119, 87, 0.5)) 
                    drop-shadow(0 0 4px rgba(217, 119, 87, 0.3));
        }
        /* Active - сужается и расширяется */
        .update-check-btn:active .claude-icon {
            animation: click-bounce 0.15s ease-out;
        }
        .update-check-btn:hover:active .claude-icon {
            animation: click-bounce-glow 0.15s ease-out;
        }
        /* Checking без hover - только пульсация размера */
        .update-check-btn.checking .claude-icon {
            animation: pulse-scale 1.2s ease-in-out infinite;
        }
        /* Checking + hover - пульсация с тенью синхронно */
        .update-check-btn.checking:hover .claude-icon {
            animation: pulse-glow 1.2s ease-in-out infinite;
        }
        /* Анимация клика без тени */
        @keyframes click-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(0.85); }
            100% { transform: scale(1); }
        }
        /* Анимация клика с тенью */
        @keyframes click-bounce-glow {
            0% { 
                transform: scale(1);
                filter: drop-shadow(0 0 2px rgba(217, 119, 87, 0.5)) 
                        drop-shadow(0 0 4px rgba(217, 119, 87, 0.3));
            }
            50% { 
                transform: scale(0.85);
                filter: drop-shadow(0 0 1px rgba(217, 119, 87, 0.4)) 
                        drop-shadow(0 0 2px rgba(217, 119, 87, 0.2));
            }
            100% { 
                transform: scale(1);
                filter: drop-shadow(0 0 2px rgba(217, 119, 87, 0.5)) 
                        drop-shadow(0 0 4px rgba(217, 119, 87, 0.3));
            }
        }
        /* Пульсация только размера */
        @keyframes pulse-scale {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        /* Пульсация размера + тени синхронно */
        @keyframes pulse-glow {
            0%, 100% { 
                transform: scale(1);
                filter: drop-shadow(0 0 2px rgba(217, 119, 87, 0.5)) 
                        drop-shadow(0 0 4px rgba(217, 119, 87, 0.3));
            }
            50% { 
                transform: scale(1.1);
                filter: drop-shadow(0 0 3px rgba(217, 119, 87, 0.6)) 
                        drop-shadow(0 0 6px rgba(217, 119, 87, 0.4));
            }
        }
        
        /* Стили для кастомного селектора языка */
        #language-menu {
            position: absolute;
        }
        #language-dropdown,
        #language-dropdown * {
            user-select: none;
            -webkit-user-select: none;
        }
        #tab-dropdown,
        #tab-dropdown * {
            user-select: none;
            -webkit-user-select: none;
        }
        #tab-dropdown.open #tab-arrow {
            transform: rotate(180deg);
        }
        .tab-option.selected {
            background-color: #f3f4f6;
            font-weight: 500;
        }
        #language-menu-inner {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        #language-menu-inner::-webkit-scrollbar {
            display: none;
        }
        #language-dropdown.open #language-arrow {
            transform: rotate(180deg);
        }
        .language-option.selected {
            background-color: #f3f4f6;
            font-weight: 500;
        }
        /* Кастомный скроллбар для меню языков */
        .lang-menu-scrollbar {
            position: absolute;
            right: 4px;
            top: 8px;
            bottom: 8px;
            width: 6px;
            background: transparent;
            border-radius: 3px;
            z-index: 10;
        }
        .lang-menu-scrollbar-thumb {
            position: absolute;
            right: 0;
            width: 4px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.15s ease, width 0.15s ease, border-radius 0.15s ease;
        }
        .lang-menu-scrollbar-thumb:hover,
        .lang-menu-scrollbar-thumb.dragging {
            width: 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* Скроллбар для модальных окон */
        .modal-scroll-area {
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.15) transparent;
        }
        .modal-scroll-area::-webkit-scrollbar {
            width: 6px;
        }
        .modal-scroll-area::-webkit-scrollbar-track {
            background: transparent;
        }
        .modal-scroll-area::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.15);
            border-radius: 3px;
        }
        .modal-scroll-area::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
        .dark .modal-scroll-area {
            scrollbar-color: rgba(255, 255, 255, 0.15) transparent;
        }
        .dark .modal-scroll-area::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
        }
        .dark .modal-scroll-area::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Стили для модального окна */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; /* Скрыто по умолчанию */
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            transition: transform 0.3s ease-out;
            transform: scale(0.95);
        }
        .modal-overlay.open {
            display: flex;
        }
        .modal-overlay.open .modal-content {
            transform: scale(1);
        }
        
        /* Стиль для кликабельной инструкции */
        .clickable-instruction {
            cursor: pointer;
            font-weight: 600;
            text-decoration: underline;
        }
        .clickable-instruction:hover {
            text-decoration: none;
        }
        
        /* Стили для редактирования вкладок */
        .block-title-input {
            transition: border-color 0.2s ease;
        }
        .block-title-input:focus {
            border-color: var(--claude-primary);
        }
        #edit-tab-btn.text-claude-accent {
            color: var(--claude-primary);
        }
        
        /* Drag & Drop стили */
        .prompt-card.dragging {
            opacity: 0.7;
            transform: scale(0.98);
            z-index: 1000;
        }
        .prompt-card.drag-over {
            border: 2px dashed var(--claude-primary);
            background: rgba(200, 120, 100, 0.05);
        }
        .drag-handle {
            cursor: grab;
            opacity: 0;
            transition: opacity 0.15s ease-out, width 0.15s ease-out, margin-right 0.15s ease-out;
            user-select: none;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 0;
            overflow: hidden;
            margin-right: 0;
            flex-shrink: 0;
        }
        .drag-mode .drag-handle {
            opacity: 0.5;
            pointer-events: auto;
            width: 24px;
            margin-right: 8px;
        }
        .drag-handle * {
            pointer-events: none;
        }
        .drag-mode .drag-handle:hover {
            opacity: 1;
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        .dark .drag-handle {
            color: #9ca3af;
        }
        .dark .drag-mode .drag-handle {
            opacity: 0.7;
        }
        
        /* Компактный режим при перетаскивании */
        .drag-mode .prompt-card:not(.dragging) {
            background: white !important;
        }
        .dark .drag-mode .prompt-card:not(.dragging) {
            background: #252525 !important;
        }
        .drag-mode .prompt-card:not(.dragging) > *:not(.card-header) {
            display: none !important;
        }
        .drag-mode .prompt-card:not(.dragging) .card-header {
            border-bottom: none !important;
            background: transparent !important;
            flex: 1;
            height: 100%;
        }
        .drag-mode .prompt-card:not(.dragging) .header-controls {
            display: none !important;
        }
        
        /* Индикатор наличия инструкции в свёрнутом режиме */
        .drag-mode .prompt-card.has-instruction::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--claude-primary);
            border-radius: 0 0 1rem 1rem;
        }
        .drag-mode .prompt-card {
            position: relative;
        }
        
        /* Скрываем кнопки при перетаскивании */
        .drag-mode .chat-button-wrapper:not(.chat-break-item),
        .drag-mode .add-block-wrapper {
            display: none !important;
        }
        
        /* Chat break в режиме drag */
        .chat-break-item {
            background: transparent;
            transition: background 0.15s ease, width 0.15s ease;
            justify-content: center;
        }
        .drag-mode .chat-break-item {
            background: var(--bg-secondary, white);
            border: 1px solid var(--border-color, #e5e5e5);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            width: fit-content;
            justify-content: flex-start;
            padding-left: 1.5rem;
            padding-right: 1.5rem;
        }
        .dark .drag-mode .chat-break-item {
            background: #252525;
            border-color: #3d3d3d;
        }
        .chat-break-item .delete-chat-break {
            opacity: 1;
        }
        .drag-mode .chat-break-item .delete-chat-break {
            display: none;
        }
        .chat-break-item.dragging {
            opacity: 0.95;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 9999;
        }
        
        /* Placeholder с анимацией */
        .drag-placeholder {
            background: rgba(200, 120, 100, 0.15);
            border: 2px dashed var(--claude-primary);
            border-radius: 1rem;
            height: 70px;
            animation: placeholder-pulse 1s ease-in-out infinite;
        }
        @keyframes placeholder-pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        /* Перетаскиваемая карточка */
        .prompt-card.dragging {
            opacity: 0.95;
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
            cursor: grabbing;
            max-height: 70px !important;
            overflow: hidden !important;
            transform: scale(1.02);
        }
        .prompt-card.dragging .textarea-content,
        .prompt-card.dragging .add-instruction-btn,
        .prompt-card.dragging .instruction-wrapper,
        .prompt-card.dragging .header-controls {
            display: none !important;
        }
        .prompt-card.dragging .card-header {
            border-bottom: none !important;
        }
        
        /* Редактируемые инструкции */
        .instruction-input {
            background: transparent;
            border: none;
            border-bottom: 1px dashed currentColor;
            outline: none;
            color: inherit;
            font-size: inherit;
            font-weight: inherit;
            width: 100%;
            min-width: 200px;
        }
        .instruction-input:focus {
            border-bottom-style: solid;
        }
        
        /* Кнопка добавления инструкции */
        .add-instruction-btn {
            opacity: 0;
            transition: opacity 0.2s;
        }
        .prompt-card:hover .add-instruction-btn {
            opacity: 1;
        }
        
        /* Переключатель темы */
        .theme-btn,
        .auto-update-btn {
            color: #6b7280;
        }
        .theme-btn.active,
        .auto-update-btn.active {
            background: white;
            color: var(--claude-primary);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .theme-btn:hover:not(.active),
        .auto-update-btn:hover:not(.active) {
            background: rgba(255,255,255,0.5);
        }
        
        /* ===== ТЁМНАЯ ТЕМА ===== */
        .dark {
            color-scheme: dark;
        }
        
        /* Хедер */
        .dark header {
            background-color: var(--bg-header);
            border-color: var(--border-light);
        }
        
        /* Панель инструментов редактирования */
        .dark #edit-toolbar {
            background-color: var(--bg-secondary);
            border-color: var(--border-light);
        }
        .dark #edit-toolbar button {
            background-color: var(--bg-tertiary);
            border-color: var(--border-light);
            color: var(--text-secondary);
        }
        .dark #edit-toolbar button:hover {
            border-color: var(--claude-primary);
            color: var(--claude-primary);
        }
        .dark #exit-edit-mode-btn {
            background-color: var(--claude-primary) !important;
            color: white !important;
        }
        .dark #lang-insert-menu,
        .dark #icon-select-menu {
            background-color: var(--bg-secondary);
            border-color: var(--border-light);
        }
        .dark .lang-insert-option {
            color: var(--text-secondary);
        }
        .dark .lang-insert-option:hover {
            background-color: var(--bg-tertiary);
        }
        .dark .icon-select-option:hover {
            background-color: var(--bg-tertiary);
        }
        
        /* Scroll container */
        .dark #scroll-container {
            background-color: var(--bg-primary);
        }
        
        /* Карточки */
        .dark .prompt-card {
            background-color: var(--bg-secondary);
        }
        .dark .prompt-card .bg-gray-50\/50,
        .dark .prompt-card .card-header {
            background-color: #252525;
        }
        /* Кнопки в заголовках карточек */
        .dark .prompt-card .edit-button,
        .dark .prompt-card .copy-button {
            color: #9ca3af;
        }
        .dark .prompt-card .edit-button:hover,
        .dark .prompt-card .copy-button:hover {
            color: var(--claude-primary);
            background-color: #3d3d3d;
        }
        /* Активная кнопка редактирования */
        .dark .prompt-card .edit-button.text-claude-accent {
            color: var(--claude-primary) !important;
            background-color: transparent !important;
        }
        .dark .prompt-card .edit-button.text-claude-accent:hover {
            background-color: #3d3d3d !important;
        }
        
        /* Кнопки undo/redo и сброс в тёмной теме */
        .dark #undo-btn:disabled,
        .dark #redo-btn:disabled,
        .dark #reset-btn {
            color: #6b7280;
        }
        .dark #undo-btn:not(:disabled),
        .dark #redo-btn:not(:disabled) {
            color: #9ca3af;
        }
        .dark #undo-btn:hover:not(:disabled),
        .dark #redo-btn:hover:not(:disabled) {
            color: var(--text-primary);
        }
        .dark #reset-btn:hover {
            color: #ef4444;
        }
        
        /* Кнопки настроек и наверх в тёмной теме */
        .dark #settings-btn,
        .dark #scroll-top-btn {
            color: #9ca3af;
        }
        .dark #settings-btn:hover,
        .dark #scroll-top-btn:hover {
            color: #d1d5db;
        }
        
        /* Текст */
        .dark .text-gray-800,
        .dark .text-gray-700 {
            color: var(--text-primary);
        }
        .dark .text-gray-600,
        .dark .text-gray-500 {
            color: var(--text-secondary);
        }
        .dark .text-gray-400 {
            color: var(--text-muted);
        }
        
        /* Textarea */
        .dark .textarea-content {
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
        }
        .dark .textarea-content.editing-mode {
            background-color: var(--bg-tertiary);
        }
        
        /* Модальные окна */
        .dark .modal-content {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-light);
        }
        .dark .modal-content h3 {
            color: var(--text-primary);
        }
        .dark .modal-content p,
        .dark .modal-content span {
            color: var(--text-secondary);
        }
        .dark .modal-content input[type="text"] {
            background-color: var(--bg-tertiary);
            border-color: var(--border-light);
            color: var(--text-primary);
        }
        .dark .modal-content input[type="text"]::placeholder {
            color: var(--text-muted);
        }
        .dark .modal-content input[type="checkbox"] {
            background-color: var(--bg-tertiary);
            border-color: var(--border-light);
        }
        .dark .modal-content .constructor-field {
            background-color: var(--bg-tertiary);
            border-color: var(--border-light);
        }
        .dark .modal-content .constructor-field input[type="text"],
        .dark .modal-content .constructor-field .field-prefix {
            background-color: var(--bg-secondary);
            border-color: var(--border-light) !important;
            color: var(--text-primary);
        }
        .dark .modal-content .constructor-field input[type="text"]::placeholder,
        .dark .modal-content .constructor-field .field-prefix::placeholder {
            color: #9CA3AF;
        }
        .dark .modal-content .constructor-field .text-gray-500,
        .dark .modal-content .constructor-field .text-gray-600 {
            color: var(--text-secondary) !important;
        }
        .dark .modal-content label {
            color: var(--text-secondary);
        }
        .dark .modal-content #constructor-instruction-text {
            background-color: var(--bg-secondary);
            border-color: var(--border-light) !important;
            color: var(--text-primary);
        }
        .dark .modal-content #constructor-instruction-text::placeholder {
            color: #9CA3AF;
        }
        
        /* Dropdown меню */
        .dark #tab-menu,
        .dark #language-menu {
            background-color: var(--bg-secondary);
            border-color: var(--border-light);
        }
        /* Кнопки открытия dropdown */
        .dark #tab-btn,
        .dark #language-btn {
            color: var(--text-secondary);
        }
        .dark #tab-btn:hover,
        .dark #language-btn:hover {
            color: var(--text-primary);
        }
        .dark .tab-option,
        .dark .language-option {
            color: var(--text-primary);
        }
        .dark .tab-option:hover,
        .dark .language-option:hover {
            background-color: #4a4a4a;
            color: #ffffff;
        }
        /* Выбранная вкладка */
        .dark .tab-option.bg-gray-50,
        .dark .bg-gray-50 {
            background-color: #3d3d3d;
        }
        /* Выбранный язык */
        .dark .language-option.selected {
            background-color: #3d3d3d;
            color: var(--text-primary);
        }
        /* Кнопки действий в меню вкладок */
        .dark .add-tab-option,
        .dark .edit-tab-option,
        .dark .export-tab-option,
        .dark .import-tab-option {
            color: var(--text-secondary);
        }
        .dark .add-tab-option:hover,
        .dark .export-tab-option:hover,
        .dark .import-tab-option:hover {
            background-color: #4a4a4a;
            color: #ffffff;
        }
        .dark .add-tab-option {
            color: var(--claude-primary);
        }
        .dark .add-tab-option:hover {
            background-color: #4a4a4a;
        }
        /* Активный режим редактирования */
        .edit-active {
            background-color: rgba(200, 120, 100, 0.1);
        }
        .dark .edit-tab-option.edit-active {
            color: #d1d5db !important;
            background-color: #3d3d3d !important;
        }
        /* Разделители */
        .dark .border-gray-200 {
            border-color: var(--border-light);
        }
        .dark .border-gray-100 {
            border-color: var(--border-light);
        }
        /* Патчноуты в модалке обновлений */
        .dark #update-notes-content {
            background-color: var(--bg-tertiary);
        }
        .dark #update-notes-content code {
            background-color: #4a4a4a;
        }
        
        /* Кнопки */
        .dark .bg-gray-100 {
            background-color: var(--bg-tertiary);
        }
        .dark .hover\:bg-gray-100:hover {
            background-color: var(--bg-tertiary);
        }
        .dark .hover\:bg-gray-200:hover {
            background-color: #4a4a4a;
        }
        
        /* Loading overlay */
        .dark .loading-overlay {
            background-color: var(--bg-primary);
        }
        .dark .loading-overlay .text-gray-700 {
            color: var(--text-secondary);
        }
        
        /* Toast */
        .dark .toast {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-light);
        }
        
        /* Разделители */
        .dark .border-gray-200,
        .dark .border-gray-100 {
            border-color: var(--border-light);
        }
        
        /* Переключатель темы и автообновлений в тёмном режиме */
        .dark .theme-btn,
        .dark .auto-update-btn {
            color: #6b7280;
        }
        .dark .theme-btn span,
        .dark .theme-btn svg {
            color: #6b7280;
        }
        .dark .theme-btn.active,
        .dark .auto-update-btn.active {
            background: var(--bg-tertiary);
            color: var(--claude-primary);
        }
        .dark .theme-btn.active span,
        .dark .theme-btn.active svg {
            color: var(--claude-primary);
        }
        .dark .theme-btn:hover:not(.active),
        .dark .auto-update-btn:hover:not(.active) {
            background: rgba(255,255,255,0.1);
        }
        
        /* Инструкции */
        .dark .bg-claude-light {
            background-color: var(--claude-light);
        }
        
        /* Кнопка добавления инструкции в тёмной теме */
        .dark .add-instruction-btn {
            background-color: var(--bg-tertiary);
        }

</style>
</head>
<body class="text-gray-800 antialiased h-screen overflow-hidden flex flex-col select-none">

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="flex flex-col items-center gap-4 text-gray-700">
            <div class="spinner"></div>
            Загрузка промптов...
        </div>
    </div>

    <!-- Header -->
    <header class="flex-shrink-0 z-50 bg-[#F5F5F7]/90 backdrop-blur-md border-b border-gray-200">
        <div class="max-w-4xl mx-auto px-6 py-4 flex justify-between items-center">
            <!-- Левая часть: иконка, селектор вкладок и селектор языка -->
            <div class="flex items-center gap-4">
                <!-- Иконка - кнопка проверки обновлений -->
                <button id="update-check-btn" class="update-check-btn" title="Проверить обновления">
                    <svg class="claude-icon h-8 w-8" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                        <path fill-rule="evenodd" d="M50 0.00034563C22.3857 0.00034563 0 22.3861 0 50.0003C0 77.6145 22.3857 100.0003 50 100.0003C77.6143 100.0003 100 77.6145 100 50.0003C100 22.3861 77.6143 0.00034563 50 0.00034563ZM50 21.5128C34.3643 21.5128 21.5125 34.3647 21.5125 50.0003C21.5125 65.6358 34.3643 78.4875 50 78.4875C65.6357 78.4875 78.4875 65.6358 78.4875 50.0003C78.4875 34.3647 65.6357 21.5128 50 21.5128Z"/>
                    </svg>
                </button>
                <!-- Кастомный селектор вкладок -->
                <div id="tab-dropdown" class="relative">
                    <button id="tab-btn" class="flex items-center gap-1.5 text-sm text-gray-700 hover:text-gray-900 font-semibold transition-colors cursor-pointer">
                        <span id="tab-btn-text">Default</span>
                        <svg class="w-3 h-3 transition-transform" id="tab-arrow" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                        </svg>
                    </button>
                    <div id="tab-menu" class="hidden absolute left-0 top-full mt-2 bg-white rounded-xl shadow-lg border border-gray-200 w-[180px] z-[100] overflow-hidden">
                        <div class="py-2">
                            <div class="tab-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="default">Default</div>
                            <div class="tab-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="task4">Task4</div>
                        </div>
                    </div>
                </div>
                <!-- Кастомный селектор языка -->
                <div id="language-dropdown" class="relative">
                    <button id="language-btn" class="flex items-center gap-1.5 text-sm text-gray-600 hover:text-gray-800 font-medium transition-colors cursor-pointer">
                        <span id="language-btn-text">EN Английский</span>
                        <svg class="w-3 h-3 transition-transform" id="language-arrow" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                        </svg>
                    </button>
                    <div id="language-menu" class="hidden absolute left-1/2 -translate-x-1/2 top-full mt-2 bg-white rounded-xl shadow-lg border border-gray-200 min-w-[180px] z-[100] overflow-hidden">
                        <div id="language-menu-inner" class="py-2 max-h-[300px] overflow-y-auto pr-2">
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="bg">BG Болгарский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="cz">CZ Чешский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="de">DE Немецкий</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="dk">DK Датский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="en">EN Английский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="es">ES Испанский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="fi">FI Финский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="fr">FR Французский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="gr">GR Греческий</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="hr">HR Хорватский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="hu">HU Венгерский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="it">IT Итальянский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="nl">NL Голландский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="no">NO Норвежский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="pl">PL Польский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="pt">PT Португальский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="ro">RO Румынский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="se">SE Шведский</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="sk">SK Словацкий</div>
                            <div class="language-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors" data-value="sl">SL Словенский</div>
                        </div>
                        <div id="lang-scrollbar" class="lang-menu-scrollbar">
                            <div class="lang-menu-scrollbar-thumb"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="flex items-center gap-4">
                <!-- Кнопки Undo/Redo -->
                <div class="flex items-center gap-1">
                    <button id="undo-btn" class="p-1.5 text-gray-400 hover:text-gray-600 disabled:text-gray-300 disabled:cursor-not-allowed transition-colors" title="Отменить (Ctrl+Z)" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M3 10h10a5 5 0 0 1 5 5v2M3 10l4-4M3 10l4 4" />
                        </svg>
                    </button>
                    <button id="redo-btn" class="p-1.5 text-gray-400 hover:text-gray-600 disabled:text-gray-300 disabled:cursor-not-allowed transition-colors" title="Повторить (Ctrl+Y)" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M21 10H11a5 5 0 0 0-5 5v2M21 10l-4-4M21 10l-4 4" />
                        </svg>
                    </button>
                </div>
                <button id="reset-btn" class="text-sm text-gray-400 hover:text-red-500 font-medium transition-colors" title="Сбросить все промпты">
                    Сброс
                </button>
                <button id="scroll-top-btn" class="text-sm text-gray-500 hover:text-gray-700 font-medium transition-colors">
                    Наверх ↑
                </button>
                <!-- Кнопка настроек -->
                <button id="settings-btn" class="p-1.5 text-gray-400 hover:text-gray-600 transition-colors" title="Настройки">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </button>
            </div>
        </div>
    </header>
    
    <!-- Панель инструментов редактирования -->
    <div id="edit-toolbar" class="hidden bg-gray-50 border-b border-gray-200 py-2 px-6">
        <div class="max-w-4xl mx-auto flex items-center gap-4">
            <!-- Панель для редактирования промптов -->
            <div id="prompt-tools" class="flex items-center gap-3">
                <span class="text-xs text-gray-500 font-medium">Вставить:</span>
                
                <!-- Кнопка вставки lang блока -->
                <div class="relative">
                    <button id="insert-lang-btn" class="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-gray-600 bg-white border border-gray-200 rounded-lg hover:border-claude-accent hover:text-claude-accent transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />
                        </svg>
                        Язык
                    </button>
                    <div id="lang-insert-menu" class="hidden absolute top-full left-0 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg z-50 w-56 max-h-60 overflow-y-auto">
                        <!-- Меню генерируется динамически в JS -->
                    </div>
                </div>
                
                <!-- Кнопка вставки UTF блока кодировки -->
                <button id="insert-utf-btn" class="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-gray-600 bg-white border border-gray-200 rounded-lg hover:border-claude-accent hover:text-claude-accent transition-colors" title="Вставить блок UTF-8 кодировки">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14" />
                    </svg>
                    UTF
                </button>
                
                <!-- Разделитель -->
                <div class="h-4 w-px bg-gray-600"></div>
                
                <!-- Кнопка изменения порядка блоков -->
                <button id="reorder-blocks-btn" class="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-gray-600 bg-white border border-gray-200 rounded-lg hover:border-claude-accent hover:text-claude-accent transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                    </svg>
                    <span id="reorder-btn-text">Порядок</span>
                </button>
            </div>
            
            <!-- Панель для редактирования инструкций (скрыта по умолчанию) -->
            <div id="instruction-tools" class="hidden flex items-center gap-3">
                <span class="text-xs text-gray-500 font-medium">Инструкция:</span>
                
                <!-- Выбор иконки -->
                <div class="relative">
                    <button id="select-icon-btn" class="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-gray-600 bg-white border border-gray-200 rounded-lg hover:border-claude-accent hover:text-claude-accent transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                        </svg>
                        Иконка
                    </button>
                    <div id="icon-select-menu" class="hidden absolute top-full left-0 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg z-50 p-2">
                        <div class="flex gap-1">
                            <!-- Info -->
                            <button class="icon-select-option p-2 rounded hover:bg-gray-100 text-claude-accent" data-icon="info" title="Информация">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <!-- Paperclip -->
                            <button class="icon-select-option p-2 rounded hover:bg-gray-100 text-claude-accent" data-icon="paperclip" title="Прикрепить">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <!-- Edit -->
                            <button class="icon-select-option p-2 rounded hover:bg-gray-100 text-claude-accent" data-icon="edit" title="Редактировать">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                </svg>
                            </button>
                            <!-- Refresh -->
                            <button class="icon-select-option p-2 rounded hover:bg-gray-100 text-claude-accent" data-icon="refresh" title="Обновить">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Создание модального окна ввода -->
                <button id="create-replace-modal-btn" class="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-gray-600 bg-white border border-gray-200 rounded-lg hover:border-claude-accent hover:text-claude-accent transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                    </svg>
                    Окно ввода
                </button>
            </div>
            
            <!-- Кнопка выхода из режима редактирования -->
            <div class="ml-auto">
                <button id="exit-edit-mode-btn" class="exit-edit-btn flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-white bg-claude-accent rounded-lg transition-all">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                    </svg>
                    Готово
                </button>
            </div>
        </div>
    </div>

    <!-- Scrollable Content Container -->
    <div id="scroll-container" class="flex-1 overflow-y-auto bg-[#F5F5F7]">
        <!-- Main Content -->
        <main id="app" class="max-w-4xl mx-auto px-6 pt-8 pb-6 space-y-6 hidden">
        <!-- Контент будет внедрен сюда с помощью JS -->
    </main>
    </div>
    
    <!-- Toast Notification -->
    <div id="toast" class="toast fixed bottom-8 left-1/2 bg-gray-900 text-white px-6 py-3 rounded-full shadow-lg font-medium text-sm flex items-center gap-2 z-50">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
        </svg>
        <span id="toast-text">Скопировано в буфер</span>
    </div>
    
    <!-- МОДАЛЬНОЕ ОКНО ДЛЯ ЗАМЕНЫ КЛЮЧЕВОГО СЛОВА -->
    <!-- ИСПРАВЛЕНИЕ: Удалено onclick="hideModal(event)" из HTML. Логика закрытия перенесена в JS на mousedown. -->
    <div id="keyword-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h3 class="text-lg font-semibold mb-4 text-gray-800">Заменить ключевое слово и контекст</h3>
            
            <div class="mb-2">
                <label class="block text-sm font-medium text-gray-700 mb-1">Ключевое слово</label>
                <input type="text" id="new-keyword-input" 
                       class="w-full px-4 py-2 border-2 border-gray-200 rounded-lg focus:border-claude-accent focus:outline-none text-gray-700 transition-colors"
                       placeholder="Введите ключевое слово...">
            </div>
            
            <!-- Кнопка добавления контекста (показывается когда контекст скрыт) -->
            <div id="add-context-btn-wrapper" class="mb-4 hidden">
                <button type="button" id="add-context-btn" 
                        class="flex items-center gap-1 text-sm text-gray-500 hover:text-claude-accent transition-colors">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                    </svg>
                    <span>Добавить контекст</span>
                </button>
            </div>
            
            <!-- Поле контекста с кнопкой удаления -->
            <div id="context-field-wrapper" class="mb-2">
                <label class="block text-sm font-medium text-gray-700 mb-1">Контекст</label>
                <div class="flex gap-2">
                    <input type="text" id="new-sport-input" 
                           class="flex-1 px-4 py-2 border-2 border-gray-200 rounded-lg focus:border-claude-accent focus:outline-none text-gray-700 transition-colors"
                           placeholder="">
                    <button type="button" id="remove-context-btn" 
                            class="px-3 py-2 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors"
                            title="Убрать контекст">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <div class="flex justify-end gap-3 mt-6">
                <button onclick="hideModal()" class="px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                    Отмена
                </button>
                <button id="apply-keyword-btn" 
                        class="px-4 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg shadow-claude hover:bg-opacity-90 transition-all focus:outline-none focus:ring-2 ring-claude-accent focus:ring-opacity-50">
                    Применить
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно сброса -->
    <div id="reset-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h3 class="text-lg font-semibold mb-4 text-gray-800">Сбросить все промпты</h3>
            <p class="text-sm text-gray-600 mb-4">Вы уверены, что хотите сбросить все промпты к стандартным значениям?</p>
            <p class="text-sm text-red-500 font-medium">Это действие нельзя отменить.</p>
            
            <div class="flex justify-end gap-3 mt-6">
                <button onclick="hideResetModal()" class="px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                    Отмена
                </button>
                <button id="confirm-reset-btn" 
                        class="px-4 py-2 text-sm font-medium text-white bg-red-500 rounded-lg hover:bg-red-600 transition-all focus:outline-none focus:ring-2 ring-red-500 focus:ring-opacity-50">
                    Сбросить
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно конструктора полей ввода -->
    <div id="input-constructor-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 500px; max-height: 90vh; display: flex; flex-direction: column;">
            <h3 class="text-lg font-semibold mb-4 text-gray-800">Настройка окна ввода</h3>
            
            <!-- Текст инструкции (отображается в оранжевой полосе) -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Текст сноски</label>
                <input type="text" id="constructor-instruction-text" 
                       class="w-full px-4 py-2 border-2 border-gray-200 rounded-lg focus:border-claude-accent focus:outline-none text-gray-700 transition-colors"
                       placeholder="Например: Заменить ключевое слово">
            </div>
            
            <div class="border-t border-gray-200 pt-4 mb-2">
                <label class="block text-sm font-medium text-gray-700 mb-2">Поля в модальном окне</label>
            </div>
            
            <div id="constructor-fields" class="modal-scroll-area space-y-3 mb-4 flex-1" style="max-height: 40vh;">
                <!-- Поля будут добавляться динамически -->
            </div>
            
            <button type="button" id="add-constructor-field-btn" 
                    class="flex items-center gap-1 text-sm text-claude-accent hover:text-claude-accent/80 transition-colors mb-4">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                </svg>
                <span>Добавить поле</span>
            </button>
            
            <div class="flex justify-end gap-3 mt-2">
                <button onclick="hideInputConstructorModal()" class="px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                    Отмена
                </button>
                <button id="save-constructor-btn" 
                        class="px-4 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg shadow-claude hover:shadow-lg hover:ring-2 hover:ring-claude-accent hover:ring-offset-2 transition-all">
                    Сохранить
                </button>
            </div>
        </div>
    </div>
    
    <!-- Динамическое модальное окно ввода (runtime) -->
    <div id="dynamic-input-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()" style="max-height: 90vh; display: flex; flex-direction: column;">
            <h3 id="dynamic-modal-title" class="text-lg font-semibold mb-4 text-gray-800">Ввод данных</h3>
            
            <div id="dynamic-modal-fields" class="modal-scroll-area space-y-3 mb-4 flex-1" style="max-height: 60vh;">
                <!-- Поля будут добавляться динамически -->
            </div>
            
            <div class="flex justify-end gap-3 mt-2">
                <button onclick="hideDynamicInputModal()" class="px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                    Отмена
                </button>
                <button id="apply-dynamic-input-btn" 
                        class="px-4 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg shadow-claude hover:shadow-lg hover:ring-2 hover:ring-claude-accent hover:ring-offset-2 transition-all">
                    Применить
                </button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно подтверждения импорта -->
    <div id="import-confirm-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h3 class="text-lg font-semibold mb-4 text-gray-800">Подтверждение импорта</h3>
            <p id="import-confirm-message" class="text-sm text-gray-600 mb-4"></p>
            
            <div class="flex justify-end gap-3 mt-6">
                <button id="import-cancel-btn" class="px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                    Отмена
                </button>
                <button id="import-confirm-btn" 
                        class="px-4 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg hover:opacity-90 transition-all focus:outline-none focus:ring-2 ring-claude-accent focus:ring-opacity-50">
                    Перезаписать
                </button>
            </div>
        </div>
    </div>

    <!-- Модалка уведомлений (для "Нельзя удалить...") -->
    <div id="alert-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 360px;">
            <div class="flex items-start gap-3 mb-4">
                <div class="flex-shrink-0 w-10 h-10 rounded-full bg-claude-accent/10 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-claude-accent" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                </div>
                <div>
                    <h3 id="alert-title" class="text-lg font-semibold text-gray-800">Уведомление</h3>
                    <p id="alert-message" class="text-sm text-gray-600 mt-1"></p>
                </div>
            </div>
            
            <div class="flex justify-end">
                <button id="alert-ok-btn" class="px-6 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg hover:opacity-90 transition-all focus:outline-none focus:ring-2 ring-claude-accent focus:ring-opacity-50">
                    OK
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно обновления -->
    <div id="update-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 450px;">
            <!-- Состояние: обновление доступно -->
            <div id="update-available-state">
                <h3 class="text-lg font-semibold mb-4 text-gray-800">🎉 Доступно обновление!</h3>
                <p class="text-sm text-gray-600 mb-4">
                    Новая версия <span id="update-version" class="font-semibold text-claude-accent"></span> готова к установке.
                </p>
                
                <!-- Патчноуты -->
                <div id="update-notes" class="hidden mb-4">
                    <p class="text-xs font-medium text-gray-500 tracking-wider mb-2">Что нового:</p>
                    <div id="update-notes-content" class="text-sm text-gray-600 bg-gray-50 rounded-lg p-3 max-h-[200px] overflow-y-auto border border-gray-100"></div>
                </div>
                
                <p class="text-xs text-gray-400 mb-2">Обновление будет загружено и установлено автоматически.</p>
                
                <div class="flex justify-end gap-3 mt-6">
                    <button id="update-later-btn" class="px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                        Позже
                    </button>
                    <button id="install-update-btn" 
                            class="px-4 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg hover:opacity-90 transition-all focus:outline-none focus:ring-2 ring-claude-accent focus:ring-opacity-50">
                        Обновить сейчас
                    </button>
                </div>
            </div>
            
            <!-- Состояние: последняя версия -->
            <div id="update-latest-state" class="hidden">
                <h3 class="text-lg font-semibold mb-4 text-gray-800">✓ Последняя версия</h3>
                <p class="text-sm text-gray-600 mb-4">
                    У вас установлена актуальная версия <span id="current-version" class="font-semibold text-claude-accent"></span>
                </p>
                
                <div class="flex justify-end mt-6">
                    <button id="update-ok-btn" 
                            class="px-4 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg hover:opacity-90 transition-all focus:outline-none focus:ring-2 ring-claude-accent focus:ring-opacity-50">
                        ОК
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- МОДАЛЬНОЕ ОКНО НАСТРОЕК -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 400px; padding: 1.5rem;">
            <h3 class="text-lg font-semibold mb-4 text-gray-800">Настройки</h3>
            
            <!-- Переключатель автообновлений -->
            <div class="mb-4">
                <div class="flex items-center justify-between">
                    <div class="flex flex-col justify-center">
                        <span class="text-sm font-medium text-gray-700 leading-tight">Автообновление</span>
                        <p class="text-xs text-gray-500 leading-tight">Проверять обновления при запуске</p>
                    </div>
                    <div class="flex items-center bg-gray-100 rounded-lg p-0.5 flex-shrink-0">
                        <button id="auto-update-off" class="auto-update-btn flex items-center justify-center w-8 h-8 rounded-md transition-all" title="Выключено">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                        <button id="auto-update-on" class="auto-update-btn flex items-center justify-center w-8 h-8 rounded-md transition-all" title="Включено">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Переключатель темы -->
            <div class="mb-4">
                <div class="flex items-center justify-between">
                    <span class="text-sm font-medium text-gray-700">Тема оформления</span>
                    <div class="flex items-center bg-gray-100 rounded-lg p-0.5">
                        <button id="theme-light" class="theme-btn flex items-center justify-center w-8 h-8 rounded-md transition-all" title="Светлая тема">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                            </svg>
                        </button>
                        <button id="theme-auto" class="theme-btn flex items-center justify-center w-8 h-8 rounded-md transition-all" title="Авто">
                            <span class="text-sm font-bold">A</span>
                        </button>
                        <button id="theme-dark" class="theme-btn flex items-center justify-center w-8 h-8 rounded-md transition-all" title="Тёмная тема">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Hidden input для импорта файлов -->
            <input type="file" id="import-file-input" accept=".json" multiple class="hidden">
            
            <!-- Версия и кнопка закрытия -->
            <div class="pt-3 border-t border-gray-200 flex items-center justify-between">
                <span id="version-label" class="text-xs text-gray-400 cursor-default select-none">
                    Версия: <span id="settings-version">3.5.8</span>
                </span>
                <button onclick="hideSettingsModal()" class="px-4 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg hover:opacity-90 transition-colors">
                    Закрыть
                </button>
            </div>
        </div>
    </div>

    <!-- МОДАЛЬНОЕ ОКНО ДОБАВЛЕНИЯ ВКЛАДКИ -->
    <div id="add-tab-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h3 class="text-lg font-semibold mb-4 text-gray-800">Новая вкладка</h3>
            <input type="text" id="new-tab-name" placeholder="Название вкладки" 
                   class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-claude-accent mb-4">
            <div class="flex justify-end gap-3">
                <button onclick="hideAddTabModal()" class="px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                    Отмена
                </button>
                <button id="confirm-add-tab-btn" class="px-4 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg hover:opacity-90 transition-colors">
                    Создать
                </button>
            </div>
        </div>
    </div>
    
    <!-- МОДАЛЬНОЕ ОКНО ПЕРЕИМЕНОВАНИЯ ВКЛАДКИ -->
    <div id="rename-tab-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h3 class="text-lg font-semibold mb-4 text-gray-800">Переименовать вкладку</h3>
            <input type="hidden" id="rename-tab-id">
            <input type="text" id="rename-tab-name" placeholder="Название вкладки" 
                   class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-claude-accent mb-4">
            <div class="flex justify-end gap-3">
                <button onclick="hideRenameTabModal()" class="px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                    Отмена
                </button>
                <button id="confirm-rename-tab-btn" class="px-4 py-2 text-sm font-medium text-white bg-claude-accent rounded-lg hover:opacity-90 transition-colors">
                    Сохранить
                </button>
            </div>
        </div>
    </div>
    
    <!-- МОДАЛЬНОЕ ОКНО УДАЛЕНИЯ ВКЛАДКИ -->
    <div id="delete-tab-modal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h3 class="text-lg font-semibold mb-2 text-gray-800">Удалить вкладку?</h3>
            <input type="hidden" id="delete-tab-id">
            <p class="text-sm text-gray-600 mb-4">Вкладка "<span id="delete-tab-name" class="font-medium"></span>" и все её блоки будут удалены. Это действие нельзя отменить.</p>
            <div class="flex justify-end gap-3">
                <button onclick="hideDeleteTabModal()" class="px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                    Отмена
                </button>
                <button id="confirm-delete-tab-btn" class="px-4 py-2 text-sm font-medium text-white bg-red-500 rounded-lg hover:bg-red-600 transition-colors">
                    Удалить
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- КОНФИГУРАЦИЯ ЛОКАЛЬНОГО ХРАНЕНИЯ ---
        const LOCAL_STORAGE_KEY = 'ai-prompts-manager-data';
        const LOCAL_STORAGE_KEY_TASK4 = 'ai-prompts-manager-data-task4';
        const LANGUAGE_STORAGE_KEY = 'ai-prompts-manager-language';
        const TAB_STORAGE_KEY = 'ai-prompts-manager-tab';
        
        // Текущая вкладка
        let currentTab = localStorage.getItem(TAB_STORAGE_KEY) || 'default';
        const DATA_VERSION_KEY = 'ai-prompts-manager-version';
        const APP_VERSION_KEY = 'ai-prompts-manager-app-version';
        const CURRENT_DATA_VERSION = 4; // Увеличить при изменении структуры блоков
        const CLAUDE_NEW_CHAT_URL = 'https://claude.ai/new'; 
        
        // Номер блока, к которому применяется замена ключевого слова
        const KEYWORD_SECTION_NUMBER = '1'; 
        
        // Глобальная функция экранирования HTML для предотвращения XSS
        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }
        
        // --- СИСТЕМА ВКЛАДОК ---
        const TABS_STORAGE_KEY = 'ai-prompts-manager-tabs';
        const SETTINGS_STORAGE_KEY = 'ai-prompts-manager-settings';
        let isEditMode = false; // Режим редактирования вкладки
        let isAdminMode = false; // Режим администратора (тройной клик по версии)
        
        // Настройки по умолчанию
        const DEFAULT_SETTINGS = {
            autoUpdate: true,
            theme: 'auto' // 'light', 'dark', 'auto'
        };
        
        // Получить настройки
        function getSettings() {
            try {
                const data = localStorage.getItem(SETTINGS_STORAGE_KEY);
                return data ? { ...DEFAULT_SETTINGS, ...JSON.parse(data) } : DEFAULT_SETTINGS;
            } catch (e) {
                return DEFAULT_SETTINGS;
            }
        }
        
        // Сохранить настройки
        function saveSettings(settings) {
            localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
        }
        
        // Дефолтная конфигурация загружается из DEFAULT_CONFIG (внизу файла)
        // Все вкладки редактируемые
        
        // Получить все вкладки из localStorage
        function getAllTabs() {
            try {
                const data = localStorage.getItem(TABS_STORAGE_KEY);
                if (data) {
                    return JSON.parse(data);
                }
                // Если нет данных - инициализируем из дефолтной конфигурации
                initializeDefaultTabs();
                return JSON.parse(localStorage.getItem(TABS_STORAGE_KEY) || '{}');
            } catch (e) {
                console.error('Error loading tabs:', e);
                return {};
            }
        }
        
        // Сохранить все вкладки
        function saveAllTabs(tabs) {
            localStorage.setItem(TABS_STORAGE_KEY, JSON.stringify(tabs));
        }
        
        // Получить конкретную вкладку
        function getTab(tabId) {
            const tabs = getAllTabs();
            return tabs[tabId] || null;
        }
        
        // Сохранить конкретную вкладку
        function saveTab(tabId, tabData) {
            const tabs = getAllTabs();
            tabs[tabId] = tabData;
            saveAllTabs(tabs);
        }
        
        function generateTabId() {
            return 'tab_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        function generateItemId() {
            return 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Миграция старого формата (blocks + chatBreaks) в новый (items)
        function migrateTabToItems(tab) {
            if (tab.items) return tab; // Уже мигрирован
            
            const items = [];
            const blocks = tab.blocks || [];
            const chatBreaks = tab.chatBreaks || [];
            const legacyChatBreak = tab.chatBreakAfter;
            
            blocks.forEach(block => {
                // Добавляем блок
                items.push({
                    type: 'block',
                    id: block.id || generateItemId(),
                    title: block.title,
                    content: block.content || '',
                    instruction: block.instruction || null
                });
                
                // Проверяем нужен ли chatBreak после этого блока
                if (chatBreaks.includes(block.number) || block.number === legacyChatBreak) {
                    items.push({
                        type: 'chatBreak',
                        id: generateItemId()
                    });
                }
            });
            
            // Обновляем структуру
            tab.items = items;
            delete tab.blocks;
            delete tab.chatBreaks;
            delete tab.chatBreakAfter;
            
            return tab;
        }
        
        // Получить items вкладки (с миграцией если нужно)
        function getTabItems(tabId) {
            const tabs = getAllTabs();
            const tab = tabs[tabId];
            if (!tab) return [];
            
            // Мигрируем если нужно
            if (!tab.items) {
                migrateTabToItems(tab);
                saveAllTabs(tabs);
            }
            
            return tab.items || [];
        }
        
        // Получить только блоки (для совместимости)
        function getTabBlocks(tabId) {
            const items = getTabItems(tabId);
            let blockNumber = 1;
            return items
                .filter(item => item.type === 'block')
                .map(item => ({
                    ...item,
                    number: String(blockNumber++)
                }));
        }
        
        function createNewTab(name) {
            saveToUndoStack(); // Сохраняем состояние перед изменением
            const tabs = getAllTabs();
            const id = generateTabId();
            const maxOrder = Math.max(0, ...Object.values(tabs).map(t => t.order || 0));
            tabs[id] = {
                id,
                name,
                order: maxOrder + 1,
                items: [{ 
                    type: 'block',
                    id: generateItemId(),
                    title: "Блок 1", 
                    content: "" 
                }]
            };
            saveAllTabs(tabs);
            saveToUndoStack(); // Сохраняем состояние после изменения
            return id;
        }
        
        function updateTab(id, updates) {
            saveToUndoStack(); // Сохраняем состояние перед изменением
            const tabs = getAllTabs();
            if (tabs[id]) {
                tabs[id] = { ...tabs[id], ...updates };
                saveAllTabs(tabs);
                saveToUndoStack(); // Сохраняем состояние после изменения
            }
        }
        
        function deleteTab(id) {
            const tabs = getAllTabs();
            
            // Нельзя удалить последнюю вкладку
            if (Object.keys(tabs).length <= 1) {
                showAlert('Нельзя удалить последнюю вкладку');
                return false;
            }
            
            saveToUndoStack(); // Сохраняем состояние перед изменением
            delete tabs[id];
            saveAllTabs(tabs);
            // Удаляем данные контента вкладки
            localStorage.removeItem(`ai-prompts-manager-${id}`);
            saveToUndoStack(); // Сохраняем состояние после изменения
            return true;
        }
        
        function addBlockToTab(tabId) {
            saveToUndoStack(); // Сохраняем состояние перед изменением
            const tabs = getAllTabs();
            if (!tabs[tabId]) return;
            
            // Мигрируем если нужно
            if (!tabs[tabId].items) {
                migrateTabToItems(tabs[tabId]);
            }
            
            const items = tabs[tabId].items;
            const blockCount = items.filter(i => i.type === 'block').length;
            const newBlock = {
                type: 'block',
                id: generateItemId(),
                title: `Блок ${blockCount + 1}`,
                content: ''
            };
            items.push(newBlock);
            saveAllTabs(tabs);
            saveToUndoStack(); // Сохраняем состояние после изменения
            return newBlock.id;
        }
        
        function addChatBreakToTab(tabId) {
            saveToUndoStack(); // Сохраняем состояние перед изменением
            const tabs = getAllTabs();
            if (!tabs[tabId]) return;
            
            // Мигрируем если нужно
            if (!tabs[tabId].items) {
                migrateTabToItems(tabs[tabId]);
            }
            
            const items = tabs[tabId].items;
            // Добавляем в конец
            items.push({
                type: 'chatBreak',
                id: generateItemId()
            });
            saveAllTabs(tabs);
            saveToUndoStack(); // Сохраняем состояние после изменения
        }
        
        function removeItemFromTab(tabId, itemId) {
            const tabs = getAllTabs();
            if (!tabs[tabId] || !tabs[tabId].items) return;
            
            const items = tabs[tabId].items;
            const blockCount = items.filter(i => i.type === 'block').length;
            const itemToRemove = items.find(i => i.id === itemId);
            
            // Нельзя удалить последний блок
            if (itemToRemove?.type === 'block' && blockCount <= 1) {
                showAlert('Нельзя удалить последний блок');
                return;
            }
            
            saveToUndoStack(); // Сохраняем состояние перед изменением
            tabs[tabId].items = items.filter(i => i.id !== itemId);
            saveAllTabs(tabs);
            saveToUndoStack(); // Сохраняем состояние после изменения
        }
        
        function removeBlockFromTab(tabId, blockNumber) {
            // Находим блок по номеру
            const blocks = getTabBlocks(tabId);
            const block = blocks.find(b => b.number === blockNumber);
            if (block) {
                removeItemFromTab(tabId, block.id);
            }
        }
        
        function updateBlockTitle(tabId, blockNumber, newTitle) {
            saveToUndoStack(); // Сохраняем состояние перед изменением
            const tabs = getAllTabs();
            if (!tabs[tabId] || !tabs[tabId].items) return;
            
            // Находим блок по номеру
            const blocks = getTabBlocks(tabId);
            const block = blocks.find(b => b.number === blockNumber);
            if (!block) return;
            
            // Обновляем в items
            const item = tabs[tabId].items.find(i => i.id === block.id);
            if (item) {
                item.title = newTitle;
                saveAllTabs(tabs);
                saveToUndoStack(); // Сохраняем состояние после изменения
            }
        }
        
        function updateBlockContent(tabId, blockNumber, newContent) {
            const tabs = getAllTabs();
            if (!tabs[tabId] || !tabs[tabId].items) return;
            
            const blocks = getTabBlocks(tabId);
            const block = blocks.find(b => b.number === blockNumber);
            if (!block) return;
            
            const item = tabs[tabId].items.find(i => i.id === block.id);
            if (item) {
                item.content = newContent;
                saveAllTabs(tabs);
            }
        }
        
        // Добавление инструкции к блоку
        function updateBlockInstruction(tabId, blockNumber, instruction) {
            saveToUndoStack(); // Сохраняем состояние перед изменением
            const tabs = getAllTabs();
            if (!tabs[tabId] || !tabs[tabId].items) return;
            
            const blocks = getTabBlocks(tabId);
            const block = blocks.find(b => b.number === blockNumber);
            if (!block) return;
            
            const item = tabs[tabId].items.find(i => i.id === block.id);
            if (item) {
                item.instruction = instruction;
                saveAllTabs(tabs);
                saveToUndoStack(); // Сохраняем состояние после изменения
            }
        }
        
        // Обновление иконки инструкции
        function updateInstructionIcon(blockNumber, iconType) {
            const blocks = getTabBlocks(currentTab);
            const block = blocks.find(b => b.number === blockNumber);
            if (!block || !block.instruction) return;
            
            const updatedInstruction = {
                ...block.instruction,
                icon: iconType
            };
            
            updateBlockInstruction(currentTab, blockNumber, updatedInstruction);
            loadPrompts(); // Перезагружаем чтобы показать новую иконку
        }
        
        // Экспорт текущей вкладки в JSON
        async function exportConfig() {
            const tabs = getAllTabs();
            const currentTabData = tabs[currentTab];
            
            if (!currentTabData) {
                console.error('Tab not found:', currentTab);
                return;
            }
            
            // Подтягиваем контент из localStorage для каждого блока
            const savedContent = loadFromLocalStorage();
            const blocks = getTabBlocks(currentTab);
            
            // Создаём копию данных вкладки с актуальным контентом
            const exportTabData = JSON.parse(JSON.stringify(currentTabData));
            
            // Обновляем content в items на основе сохранённого контента
            let blockIndex = 0;
            exportTabData.items = exportTabData.items.map(item => {
                if (item.type === 'block') {
                    blockIndex++;
                    const blockNumber = String(blockIndex);
                    // Сначала пробуем по ID, потом по номеру (обратная совместимость)
                    const content = savedContent[item.id] !== undefined ? savedContent[item.id] : savedContent[blockNumber];
                    if (content !== undefined) {
                        return { ...item, content };
                    }
                }
                return item;
            });
            
            const config = {
                version: 1,
                exportDate: new Date().toISOString(),
                tab: exportTabData
            };
            
            const jsonContent = JSON.stringify(config, null, 2);
            const safeName = currentTabData.name.replace(/[^a-zA-Z0-9а-яА-ЯёЁ]/g, '-').toLowerCase();
            const defaultFileName = `${safeName}-${new Date().toISOString().split('T')[0]}.json`;
            
            // Проверяем, есть ли Tauri API для диалога сохранения
            if (window.__TAURI__ && window.__TAURI__.dialog) {
                try {
                    const filePath = await window.__TAURI__.dialog.save({
                        defaultPath: defaultFileName,
                        filters: [{
                            name: 'JSON',
                            extensions: ['json']
                        }]
                    });
                    
                    if (filePath) {
                        // Записываем файл через Tauri fs plugin (v2 API)
                        try {
                            if (window.__TAURI__.fs && window.__TAURI__.fs.writeTextFile) {
                                await window.__TAURI__.fs.writeTextFile(filePath, jsonContent);
                            } else {
                                // Альтернативный способ через core.invoke
                                await window.__TAURI__.core.invoke('plugin:fs|write_text_file', {
                                    path: filePath,
                                    contents: jsonContent
                                });
                            }
                            showToast('Конфигурация сохранена!');
                        } catch (writeError) {
                            console.error('Write error:', writeError);
                            showToast('Ошибка записи файла');
                        }
                    }
                } catch (e) {
                    console.error('Export error:', e);
                    // Fallback на обычное скачивание если dialog не работает
                    downloadFile(jsonContent, defaultFileName);
                    showToast('Файл скачан в папку загрузок');
                }
            } else {
                // Fallback для браузера
                downloadFile(jsonContent, defaultFileName);
            }
        }
        
        function downloadFile(content, fileName) {
            const blob = new Blob([content], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- СИСТЕМА UNDO/REDO ---
        const MAX_HISTORY_SIZE = 20;
        let undoStack = []; // Стек для отмены
        let redoStack = []; // Стек для повтора
        let isUndoRedoAction = false; // Флаг для предотвращения записи при undo/redo

        /**
         * Сохраняет полное состояние (промпты + структура tabs) в стек отмены
         */
        function saveToUndoStack() {
            if (isUndoRedoAction) return;
            
            // Сохраняем контент textarea по itemId
            const textareaState = {};
            document.querySelectorAll('.textarea-content').forEach(textarea => {
                const key = textarea.dataset.itemId || textarea.dataset.number;
                textareaState[key] = textarea.value;
            });
            
            // Сохраняем структуру всех tabs
            const tabsState = JSON.parse(JSON.stringify(getAllTabs()));
            
            // Сохраняем localStorage данные для всех вкладок
            const localStorageState = {};
            Object.keys(tabsState).forEach(tabId => {
                let key;
                if (tabId === 'default') key = LOCAL_STORAGE_KEY;
                else if (tabId === 'task4') key = LOCAL_STORAGE_KEY_TASK4;
                else key = `ai-prompts-manager-data-${tabId}`;
                const data = localStorage.getItem(key);
                if (data) localStorageState[tabId] = data;
            });
            
            const currentState = {
                textarea: textareaState,
                tabs: tabsState,
                localStorage: localStorageState,
                currentTab: currentTab
            };
            
            // Проверяем, изменилось ли состояние
            if (undoStack.length > 0) {
                const lastState = undoStack[undoStack.length - 1];
                if (JSON.stringify(lastState) === JSON.stringify(currentState)) {
                    return; // Состояние не изменилось
                }
            }
            
            undoStack.push(currentState);
            
            // Ограничиваем размер стека
            if (undoStack.length > MAX_HISTORY_SIZE) {
                undoStack.shift();
            }
            
            // Очищаем redo стек при новом действии
            redoStack = [];
            
            updateUndoRedoButtons();
        }

        /**
         * Отменяет последнее действие
         */
        function undo() {
            if (undoStack.length <= 1) return; // Нужно хотя бы 2 состояния
            
            isUndoRedoAction = true;
            
            // Сохраняем текущее состояние в redo
            const currentState = undoStack.pop();
            redoStack.push(currentState);
            
            // Восстанавливаем предыдущее состояние
            const previousState = undoStack[undoStack.length - 1];
            applyState(previousState);
            
            isUndoRedoAction = false;
            updateUndoRedoButtons();
        }

        /**
         * Повторяет отменённое действие
         */
        function redo() {
            if (redoStack.length === 0) return;
            
            isUndoRedoAction = true;
            
            // Восстанавливаем состояние из redo
            const nextState = redoStack.pop();
            undoStack.push(nextState);
            applyState(nextState);
            
            isUndoRedoAction = false;
            updateUndoRedoButtons();
        }

        // Глобальный обработчик Ctrl+Z / Ctrl+Y
        document.addEventListener('keydown', (e) => {
            // Проверяем, не находится ли фокус в редактируемой textarea
            const activeElement = document.activeElement;
            const isInEditableTextarea = activeElement && 
                activeElement.classList.contains('textarea-content') && 
                !activeElement.readOnly;
            
            // Если фокус в редактируемой textarea - пропускаем (нативный undo/redo)
            if (isInEditableTextarea) return;
            
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });

        /**
         * Применяет состояние к textarea
         */
        function applyState(state) {
            // Проверяем формат состояния (новый или старый)
            if (state.tabs) {
                // Новый формат - полное состояние
                
                // Восстанавливаем структуру tabs
                saveAllTabs(state.tabs);
                
                // Восстанавливаем localStorage данные
                if (state.localStorage) {
                    Object.keys(state.localStorage).forEach(tabId => {
                        let key;
                        if (tabId === 'default') key = LOCAL_STORAGE_KEY;
                        else if (tabId === 'task4') key = LOCAL_STORAGE_KEY_TASK4;
                        else key = `ai-prompts-manager-data-${tabId}`;
                        localStorage.setItem(key, state.localStorage[tabId]);
                    });
                }
                
                // Переключаемся на нужную вкладку и перезагружаем
                if (state.currentTab && state.currentTab !== currentTab) {
                    currentTab = state.currentTab;
                    localStorage.setItem(CURRENT_TAB_KEY, currentTab);
                }
                
                // Перезагружаем интерфейс
                loadPrompts();
                window.updateTabSelectorUI?.();
                
            } else {
                // Старый формат - только textarea (для обратной совместимости)
                document.querySelectorAll('.textarea-content').forEach(textarea => {
                    const number = textarea.dataset.number;
                    const itemId = textarea.dataset.itemId;
                    // Поддержка старого формата (по номеру) и нового (по ID)
                    const value = state[itemId] !== undefined ? state[itemId] : state[number];
                    if (value !== undefined) {
                        textarea.value = value;
                        autoResizeTextarea(textarea);
                        saveToLocalStorage(itemId, value);
                    }
                });
            }
        }

        /**
         * Обновляет состояние кнопок Undo/Redo
         */
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                undoBtn.disabled = undoStack.length <= 1;
            }
            if (redoBtn) {
                redoBtn.disabled = redoStack.length === 0;
            }
        }

                // --- КОНФИГУРАЦИЯ ЯЗЫКОВ ---
        const LANGUAGES = {
            en: {
                name: 'английский',
                genitive: 'английского',
                prepositional: 'английском',
                adjective: 'английской',
                adjectivePlural: 'английские',
                segment: 'англоязычном',
                segmentAudience: 'англоязычной',
                privacyPolicy: 'Privacy Policy',
                aboutUs: 'About Us',
                legalInfo: 'Legal Information',
                cookiePolicy: 'Cookie Policy',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для английского:
Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            de: {
                name: 'немецкий',
                genitive: 'немецкого',
                prepositional: 'немецком',
                adjective: 'немецкой',
                adjectivePlural: 'немецкие',
                segment: 'немецкоязычном',
                segmentAudience: 'немецкоязычной',
                privacyPolicy: 'Datenschutzerklärung',
                aboutUs: 'Über uns',
                legalInfo: 'Impressum',
                cookiePolicy: 'Cookie-Richtlinie',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для немецкого:
Сохраняй ВСЕ немецкие символы в оригинальном виде:
ä, ö, ü, ß, Ä, Ö, Ü

НЕ преобразовывай строчные:
ä → Ã¤
ö → Ã¶
ü → Ã¼
ß → ÃŸ

НЕ преобразовывай заглавные:
Ä → Ä
Ö → Ö
Ü → Ü

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            es: {
                name: 'испанский',
                genitive: 'испанского',
                prepositional: 'испанском',
                adjective: 'испанской',
                adjectivePlural: 'испанские',
                segment: 'испаноязычном',
                segmentAudience: 'испаноязычной',
                privacyPolicy: 'Política de privacidad',
                aboutUs: 'Sobre nosotros',
                legalInfo: 'Información legal',
                cookiePolicy: 'Política de cookies',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для испанского:
Сохраняй ВСЕ испанские символы в оригинальном виде:
á, é, í, ó, ú, ñ, ü, Á, É, Í, Ó, Ú, Ñ, Ü, ¿, ¡

НЕ преобразовывай строчные с акутом:
á → Ã¡, é → Ã©, í → Ã­, ó → Ã³, ú → Ãº

НЕ преобразовывай специальные буквы:
ñ → Ã±, ü → Ã¼

НЕ преобразовывай заглавные:
Á → Ã, É → É, Í → Ã, Ó → Ã", Ú → Ãš, Ñ → Ñ, Ü → Ü

НЕ преобразовывай знаки пунктуации:
¿ → Â¿, ¡ → Â¡

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            it: {
                name: 'итальянский',
                genitive: 'итальянского',
                prepositional: 'итальянском',
                adjective: 'итальянской',
                adjectivePlural: 'итальянские',
                segment: 'италоязычном',
                segmentAudience: 'италоязычной',
                privacyPolicy: 'Informativa sulla privacy',
                aboutUs: 'Chi siamo',
                legalInfo: 'Informazioni legali',
                cookiePolicy: 'Informativa sui cookie',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для итальянского:
Сохраняй ВСЕ итальянские символы в оригинальном виде:
à, è, é, ì, ò, ù, À, È, É, Ì, Ò, Ù

НЕ преобразовывай строчные:
à → Ã, è → è, é → é, ì → ì, ò → ò, ù → ù

НЕ преобразовывай заглавные:
À → À, È → È, É → É, Ì → Ì, Ò → Ò, Ù → Ù

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            fr: {
                name: 'французский',
                genitive: 'французского',
                prepositional: 'французском',
                adjective: 'французской',
                adjectivePlural: 'французские',
                segment: 'франкоязычном',
                segmentAudience: 'франкоязычной',
                privacyPolicy: 'Politique de confidentialité',
                aboutUs: 'À propos de nous',
                legalInfo: 'Mentions légales',
                cookiePolicy: 'Politique de cookies',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для французского:
Сохраняй ВСЕ французские символы в оригинальном виде:
à, â, ä, é, è, ê, ë, î, ï, ô, ù, û, ü, ÿ, ç, œ, æ, À, Â, Ä, É, È, Ê, Ë, Î, Ï, Ô, Ù, Û, Ü, Ÿ, Ç, Œ, Æ

НЕ преобразовывай строчные:
à → Ã , â → Ã¢, ä → Ã¤, é → Ã©, è → Ã¨, ê → Ãª, ë → Ã«
î → Ã®, ï → Ã¯, ô → Ã´, ù → Ã¹, û → Ã», ü → Ã¼, ÿ → Ã¿, ç → Ã§

НЕ преобразовывай заглавные:
À → Ã€, Â → Ã‚, Ä → Ã„, É → Ã‰, È → Ãˆ, Ê → ÃŠ, Ë → Ã‹
Î → ÃŽ, Ï → Ã, Ô → Ã", Ù → Ã™, Û → Ã›, Ü → Ãœ, Ÿ → Å¸, Ç → Ã‡

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            nl: {
                name: 'голландский',
                genitive: 'голландского',
                prepositional: 'голландском',
                adjective: 'голландской',
                adjectivePlural: 'голландские',
                segment: 'голландскоязычном',
                segmentAudience: 'голландскоязычной',
                privacyPolicy: 'Privacybeleid',
                aboutUs: 'Over ons',
                legalInfo: 'Juridische informatie',
                cookiePolicy: 'Cookiebeleid',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для голландского:
Сохраняй ВСЕ голландские символы в оригинальном виде: á, à, â, ä, é, è, ê, ë, í, ì, î, ï, ó, ò, ô, ö, ú, ù, û, ü, ý, ÿ, ç, ñ, ij, IJ, Á, À, Â, Ä, É, È, Ê, Ë, Í, Ì, Î, Ï, Ó, Ò, Ô, Ö, Ú, Ù, Û, Ü, Ý, Ÿ, Ç, Ñ

НЕ преобразовывай á → Ã¡, à → Ã , â → Ã¢, ä → Ã¤, é → Ã©, è → Ã¨, ê → Ãª, ë → Ã«
НЕ преобразовывай í → Ã­, î → Ã®, ï → Ã¯, ó → Ã³, ô → Ã´, ö → Ã¶, ú → Ãº, û → Ã»
НЕ преобразовывай ü → Ã¼, ÿ → Ã¿, ç → Ã§, ñ → Ã±, € → â‚¬
НЕ преобразовывай заглавные: Ä → Ã„, Ë → Ã‹, Ï → Ã, Ö → Ã–, Ü → Ãœ

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            pl: {
                name: 'польский',
                genitive: 'польского',
                prepositional: 'польском',
                adjective: 'польской',
                adjectivePlural: 'польские',
                segment: 'польскоязычном',
                segmentAudience: 'польскоязычной',
                privacyPolicy: 'Polityka prywatności',
                aboutUs: 'O nas',
                legalInfo: 'Informacje prawne',
                cookiePolicy: 'Polityka cookies',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для польского:
Сохраняй ВСЕ польские символы в оригинальном виде:
ą, ć, ę, ł, ń, ó, ś, ź, ż, Ą, Ć, Ę, Ł, Ń, Ó, Ś, Ź, Ż

НЕ преобразовывай строчные:
ą → Ä…, ć → Ä‡, ę → Ä™, ł → Å‚, ń → Å„
ó → Ã³, ś → Å›, ź → Åº, ż → Å¼

НЕ преобразовывай заглавные:
Ą → Ä„, Ć → Ä†, Ę → Ä˜, Ł → Å, Ń → Åƒ
Ó → Ã", Ś → Åš, Ź → Å¹, Ż → Å»

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            cz: {
                name: 'чешский',
                genitive: 'чешского',
                prepositional: 'чешском',
                adjective: 'чешской',
                adjectivePlural: 'чешские',
                segment: 'чешскоязычном',
                segmentAudience: 'чешскоязычной',
                privacyPolicy: 'Zásady ochrany osobních údajů',
                aboutUs: 'O nás',
                legalInfo: 'Právní informace',
                cookiePolicy: 'Zásady používání cookies',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для чешского:
Сохраняй ВСЕ чешские символы в оригинальном виде:
á, č, ď, é, ě, í, ň, ó, ř, š, ť, ú, ů, ý, ž, Á, Č, Ď, É, Ě, Í, Ň, Ó, Ř, Š, Ť, Ú, Ů, Ý, Ž

НЕ преобразовывай строчные:
á → Ã¡, č → Ä, ď → Ä, é → Ã©, ě → Ä›, í → Ã­
ň → Åˆ, ó → Ã³, ř → Å™, š → Å¡, ť → Å¥, ú → Ãº, ů → Å¯, ý → Ã½, ž → Å¾

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            pt: {
                name: 'португальский',
                genitive: 'португальского',
                prepositional: 'португальском',
                adjective: 'португальской',
                adjectivePlural: 'португальские',
                segment: 'португалоязычном',
                segmentAudience: 'португалоязычной',
                privacyPolicy: 'Política de Privacidade',
                aboutUs: 'Sobre nós',
                legalInfo: 'Informações legais',
                cookiePolicy: 'Política de Cookies',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для португальского:
Сохраняй ВСЕ португальские символы в оригинальном виде:
á, à, â, ã, é, ê, í, ó, ô, õ, ú, ü, ç, Á, À, Â, Ã, É, Ê, Í, Ó, Ô, Õ, Ú, Ü, Ç

НЕ преобразовывай строчные:
á → Ã¡, à → Ã , â → Ã¢, ã → Ã£, é → Ã©, ê → Ãª
í → Ã­, ó → Ã³, ô → Ã´, õ → Ãµ, ú → Ãº, ü → Ã¼, ç → Ã§

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            dk: {
                name: 'датский',
                genitive: 'датского',
                prepositional: 'датском',
                adjective: 'датской',
                adjectivePlural: 'датские',
                segment: 'датскоязычном',
                segmentAudience: 'датскоязычной',
                privacyPolicy: 'Privatlivspolitik',
                aboutUs: 'Om os',
                legalInfo: 'Juridisk information',
                cookiePolicy: 'Cookiepolitik',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для датского:
Сохраняй ВСЕ датские символы в оригинальном виде:
æ, ø, å, Æ, Ø, Å

НЕ преобразовывай:
æ → Ã¦, ø → Ã¸, å → Ã¥
Æ → Ã†, Ø → Ã˜, Å → Ã…

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            gr: {
                name: 'греческий',
                genitive: 'греческого',
                prepositional: 'греческом',
                adjective: 'греческой',
                adjectivePlural: 'греческие',
                segment: 'грекоязычном',
                segmentAudience: 'грекоязычной',
                privacyPolicy: 'Πολιτική Απορρήτου',
                aboutUs: 'Σχετικά με εμάς',
                legalInfo: 'Νομικές πληροφορίες',
                cookiePolicy: 'Πολιτική Cookies',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для греческого:
Сохраняй ВСЕ греческие символы в оригинальном виде:
α, β, γ, δ, ε, ζ, η, θ, ι, κ, λ, μ, ν, ξ, ο, π, ρ, σ, τ, υ, φ, χ, ψ, ω
ά, έ, ή, ί, ό, ύ, ώ, ϊ, ϋ, ΐ, ΰ
Α, Β, Γ, Δ, Ε, Ζ, Η, Θ, Ι, Κ, Λ, Μ, Ν, Ξ, Ο, Π, Ρ, Σ, Τ, Υ, Φ, Χ, Ψ, Ω

НЕ преобразовывай строчные:
α → Î±, β → Î², γ → Î³, δ → Î´, ε → Îµ, ζ → Î¶, η → Î·, θ → Î¸
ι → Î¹, κ → Îº, λ → Î», μ → Î¼, ν → Î½, ξ → Î¾, ο → Î¿, π → Ï€
ρ → Ï, σ → Ïƒ, τ → Ï„, υ → Ï…, φ → Ï†, χ → Ï‡, ψ → Ïˆ, ω → Ï‰

НЕ преобразовывай с ударением:
ά → Î¬, έ → Î­, ή → Î®, ί → Î¯, ό → ÏŒ, ύ → Ï, ώ → ÏŽ

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            no: {
                name: 'норвежский',
                genitive: 'норвежского',
                prepositional: 'норвежском',
                adjective: 'норвежской',
                adjectivePlural: 'норвежские',
                segment: 'норвежскоязычном',
                segmentAudience: 'норвежскоязычной',
                privacyPolicy: 'Personvernpolicy',
                aboutUs: 'Om oss',
                legalInfo: 'Juridisk informasjon',
                cookiePolicy: 'Informasjonskapsler',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для норвежского:
Сохраняй ВСЕ норвежские символы в оригинальном виде:
æ, ø, å, Æ, Ø, Å

НЕ преобразовывай:
æ → Ã¦, ø → Ã¸, å → Ã¥
Æ → Ã†, Ø → Ã˜, Å → Ã…

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            hu: {
                name: 'венгерский',
                genitive: 'венгерского',
                prepositional: 'венгерском',
                adjective: 'венгерской',
                adjectivePlural: 'венгерские',
                segment: 'венгероязычном',
                segmentAudience: 'венгероязычной',
                privacyPolicy: 'Adatvédelmi irányelvek',
                aboutUs: 'Rólunk',
                legalInfo: 'Jogi információk',
                cookiePolicy: 'Cookie szabályzat',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для венгерского:
Сохраняй ВСЕ венгерские символы в оригинальном виде:
á, é, í, ó, ö, ő, ú, ü, ű, Á, É, Í, Ó, Ö, Ő, Ú, Ü, Ű

НЕ преобразовывай:
á → Ã¡, é → Ã©, í → Ã­, ó → Ã³, ö → Ã¶, ő → Å', ú → Ãº, ü → Ã¼, ű → Å±

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            fi: {
                name: 'финский',
                genitive: 'финского',
                prepositional: 'финском',
                adjective: 'финской',
                adjectivePlural: 'финские',
                segment: 'финноязычном',
                segmentAudience: 'финноязычной',
                privacyPolicy: 'Tietosuojakäytäntö',
                aboutUs: 'Tietoa meistä',
                legalInfo: 'Oikeudelliset tiedot',
                cookiePolicy: 'Evästekäytäntö',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для финского:
Сохраняй ВСЕ финские символы в оригинальном виде:
ä, ö, å, Ä, Ö, Å

НЕ преобразовывай:
ä → Ã¤, ö → Ã¶, å → Ã¥
Ä → Ã„, Ö → Ã–, Å → Ã…

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            sk: {
                name: 'словацкий',
                genitive: 'словацкого',
                prepositional: 'словацком',
                adjective: 'словацкой',
                adjectivePlural: 'словацкие',
                segment: 'словацкоязычном',
                segmentAudience: 'словацкоязычной',
                privacyPolicy: 'Zásady ochrany osobných údajov',
                aboutUs: 'O nás',
                legalInfo: 'Právne informácie',
                cookiePolicy: 'Zásady používania cookies',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для словацкого:
Сохраняй ВСЕ словацкие символы в оригинальном виде:
á, ä, č, ď, é, í, ĺ, ľ, ň, ó, ô, ŕ, š, ť, ú, ý, ž, Á, Ä, Č, Ď, É, Í, Ĺ, Ľ, Ň, Ó, Ô, Ŕ, Š, Ť, Ú, Ý, Ž

НЕ преобразовывай:
á → Ã¡, ä → Ã¤, č → Ä, ď → Ä, é → Ã©, í → Ã­
ĺ → Äº, ľ → Ä¾, ň → Åˆ, ó → Ã³, ô → Ã´, ŕ → Å•
š → Å¡, ť → Å¥, ú → Ãº, ý → Ã½, ž → Å¾

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            sl: {
                name: 'словенский',
                genitive: 'словенского',
                prepositional: 'словенском',
                adjective: 'словенской',
                adjectivePlural: 'словенские',
                segment: 'словеноязычном',
                segmentAudience: 'словеноязычной',
                privacyPolicy: 'Politika zasebnosti',
                aboutUs: 'O nas',
                legalInfo: 'Pravne informacije',
                cookiePolicy: 'Politika piškotkov',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для словенского:
Сохраняй ВСЕ словенские символы в оригинальном виде:
č, š, ž, Č, Š, Ž

НЕ преобразовывай:
č → Ä, š → Å¡, ž → Å¾
Č → Ä†, Š → Å , Ž → Å½

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            hr: {
                name: 'хорватский',
                genitive: 'хорватского',
                prepositional: 'хорватском',
                adjective: 'хорватской',
                adjectivePlural: 'хорватские',
                segment: 'хорватскоязычном',
                segmentAudience: 'хорватскоязычной',
                privacyPolicy: 'Politika privatnosti',
                aboutUs: 'O nama',
                legalInfo: 'Pravne informacije',
                cookiePolicy: 'Politika kolačića',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для хорватского:
Сохраняй ВСЕ хорватские символы в оригинальном виде:
č, ć, đ, š, ž, Č, Ć, Đ, Š, Ž

НЕ преобразовывай:
č → Ä, ć → Ä‡, đ → Ä', š → Å¡, ž → Å¾

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            se: {
                name: 'шведский',
                genitive: 'шведского',
                prepositional: 'шведском',
                adjective: 'шведской',
                adjectivePlural: 'шведские',
                segment: 'шведскоязычном',
                segmentAudience: 'шведскоязычной',
                privacyPolicy: 'Integritetspolicy',
                aboutUs: 'Om oss',
                legalInfo: 'Juridisk information',
                cookiePolicy: 'Cookiepolicy',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для шведского:
Сохраняй ВСЕ шведские символы в оригинальном виде:
å, ä, ö, Å, Ä, Ö

НЕ преобразовывай:
å → Ã¥, ä → Ã¤, ö → Ã¶
Å → Ã…, Ä → Ã„, Ö → Ã–

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            bg: {
                name: 'болгарский',
                genitive: 'болгарского',
                prepositional: 'болгарском',
                adjective: 'болгарской',
                adjectivePlural: 'болгарские',
                segment: 'болгароязычном',
                segmentAudience: 'болгароязычной',
                privacyPolicy: 'Политика за поверителност',
                aboutUs: 'За нас',
                legalInfo: 'Правна информация',
                cookiePolicy: 'Политика за бисквитки',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для болгарского:
Сохраняй ВСЕ болгарские символы (кириллица) в оригинальном виде:
а, б, в, г, д, е, ж, з, и, й, к, л, м, н, о, п, р, с, т, у, ф, х, ц, ч, ш, щ, ъ, ь, ю, я
А, Б, В, Г, Д, Е, Ж, З, И, Й, К, Л, М, Н, О, П, Р, С, Т, У, Ф, Х, Ц, Ч, Ш, Щ, Ъ, Ь, Ю, Я

НЕ преобразовывай строчные:
а → Ð°, б → Ð±, в → Ð², г → Ð³, д → Ð´, е → Ðµ, ж → Ð¶, з → Ð·
и → Ð¸, й → Ð¹, к → Ðº, л → Ð», м → Ð¼, н → Ð½, о → Ð¾, п → Ð¿
р → Ñ€, с → Ñ, т → Ñ‚, у → Ñƒ, ф → Ñ„, х → Ñ…, ц → Ñ†, ч → Ñ‡
ш → Ñˆ, щ → Ñ‰, ъ → ÑŠ, ь → ÑŒ, ю → ÑŽ, я → Ñ

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            },
            ro: {
                name: 'румынский',
                genitive: 'румынского',
                prepositional: 'румынском',
                adjective: 'румынской',
                adjectivePlural: 'румынские',
                segment: 'румыноязычном',
                segmentAudience: 'румыноязычной',
                privacyPolicy: 'Politica de confidențialitate',
                aboutUs: 'Despre noi',
                legalInfo: 'Informații legale',
                cookiePolicy: 'Politica de cookies',
                checksBlock: `После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                checksBlockCluster: `После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, диакритические, фактические. Используй веб-поиск. Исправь при обнаружении.`,
                utfBlock: `КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для румынского:
Сохраняй ВСЕ румынские символы в оригинальном виде:
ă, â, î, ș, ț, Ă, Â, Î, Ș, Ț

НЕ преобразовывай:
ă → Äƒ, â → Ã¢, î → Ã®, ș → È™, ț → È›

Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию`
            }
        };


        // Текущий язык (по умолчанию английский)
        let currentLanguage = localStorage.getItem(LANGUAGE_STORAGE_KEY) || 'en';

        /**
         * Заменяет все формы одного языка на другой в тексте
         */
        function replaceLanguage(text, fromLang, toLang) {
            if (!fromLang || !toLang || fromLang === toLang) return text;
            
            const from = LANGUAGES[fromLang];
            const to = LANGUAGES[toLang];
            
            if (!from || !to) return text;
            
            let result = text;
            
            // UTF-8 блок - ищем по паттерну (от "КРИТИЧЕСКИ ВАЖНО" до "НЕ используй ASCII-транслитерацию")
            const utfBlockPattern = /КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для \S+:[\s\S]*?НЕ используй ASCII-транслитерацию/g;
            result = result.replace(utfBlockPattern, to.utfBlock);
            
            // Замена checksBlock (блок проверок для pillar-статьи)
            const checksBlockPattern = /После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, (?:диакритические, )?фактические\. Используй веб-поиск\. Исправь при обнаружении\./g;
            result = result.replace(checksBlockPattern, to.checksBlock);
            
            // Замена checksBlockCluster (блок проверок для кластерных статей)
            const checksBlockClusterPattern = /После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, (?:диакритические, )?фактические\. Используй веб-поиск\. Исправь при обнаружении\./g;
            result = result.replace(checksBlockClusterPattern, to.checksBlockCluster);
            
            // Названия технических страниц (точная замена)
            result = result.split(from.privacyPolicy).join(to.privacyPolicy);
            result = result.split(from.aboutUs).join(to.aboutUs);
            result = result.split(from.legalInfo).join(to.legalInfo);
            result = result.split(from.cookiePolicy).join(to.cookiePolicy);
            
            // Формы языка - используем регулярки с границами слов
            // Порядок важен: сначала длинные формы, потом короткие
            const replacePairs = [
                [from.segmentAudience, to.segmentAudience],
                [from.segment, to.segment],
                [from.adjectivePlural, to.adjectivePlural],
                [from.adjective, to.adjective],
                [from.prepositional, to.prepositional],
                [from.genitive, to.genitive],
                [from.name, to.name]
            ];
            
            for (const [fromWord, toWord] of replacePairs) {
                if (fromWord && toWord) {
                    // Экранируем спецсимволы для регулярки
                    const escaped = fromWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(escaped, 'g');
                    result = result.replace(regex, toWord);
                }
            }
            
            return result;
        }

        /**
         * Определяет язык из конкретного текста
         * @param {string} text - текст для анализа
         * @returns {string|null} - код языка или null если не определён
         */
        function detectLanguageInText(text) {
            for (const [langCode, lang] of Object.entries(LANGUAGES)) {
                // Проверяем все уникальные формы языка
                // Порядок важен: сначала более уникальные/длинные формы
                if (lang.segmentAudience && text.includes(lang.segmentAudience)) {
                    return langCode;
                }
                if (lang.segment && text.includes(lang.segment)) {
                    return langCode;
                }
                if (lang.genitive && text.includes(lang.genitive)) {
                    return langCode;
                }
                if (lang.prepositional && text.includes(lang.prepositional)) {
                    return langCode;
                }
                if (lang.adjective && text.includes(lang.adjective)) {
                    return langCode;
                }
                // Проверяем технические страницы (уникальные для каждого языка)
                if (lang.privacyPolicy && lang.privacyPolicy !== 'Privacy Policy' && text.includes(lang.privacyPolicy)) {
                    return langCode;
                }
            }
            return null;
        }

        /**
         * Определяет язык из текста промптов (первый блок)
         */
        function detectLanguageFromText() {
            // Берём текст из первого textarea (блок 1)
            const firstTextarea = document.querySelector('.textarea-content');
            if (!firstTextarea) return 'en';
            
            const detected = detectLanguageInText(firstTextarea.value);
            return detected || 'en'; // По умолчанию английский
        }

        /**
         * Инициализация селектора вкладок
         */
        function initTabSelector() {
            const dropdown = document.getElementById('tab-dropdown');
            const btn = document.getElementById('tab-btn');
            const btnText = document.getElementById('tab-btn-text');
            const menu = document.getElementById('tab-menu');
            
            // Состояние для inline-подтверждения удаления
            let pendingDeleteTabId = null;
            
            // Функция рендеринга меню вкладок
            function renderTabMenu() {
                const allTabs = getAllTabs();
                
                // Сортируем вкладки по order
                const sortedTabs = Object.values(allTabs).sort((a, b) => (a.order || 0) - (b.order || 0));
                
                let html = '<div class="py-2">';
                
                // Все вкладки
                sortedTabs.forEach(tab => {
                    const isSelected = currentTab === tab.id;
                    const isPendingDelete = pendingDeleteTabId === tab.id;
                    
                    html += `
                        <div class="tab-option px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer transition-colors flex items-center justify-between group ${isSelected ? 'bg-gray-50' : ''}" data-value="${tab.id}">
                            <span class="tab-name truncate max-w-[120px] ${isPendingDelete ? 'hidden' : ''}">${tab.name}</span>
                            <span class="delete-confirm-text text-red-500 text-xs ${isPendingDelete ? '' : 'hidden'}">Удалить?</span>
                            ${isAdminMode ? `
                            <div class="tab-actions flex items-center gap-1 ${isPendingDelete ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'} transition-opacity">
                                <button class="tab-rename-btn p-1 hover:bg-gray-200 rounded ${isPendingDelete ? 'hidden' : ''}" data-tab-id="${tab.id}" title="Переименовать">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                    </svg>
                                </button>
                                <button class="tab-delete-btn p-1 hover:bg-red-100 rounded ${isPendingDelete ? 'hidden' : ''}" data-tab-id="${tab.id}" title="Удалить">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                    </svg>
                                </button>
                                <button class="tab-confirm-delete-btn p-1 hover:bg-red-200 rounded bg-red-100 ${isPendingDelete ? '' : 'hidden'}" data-tab-id="${tab.id}" title="Подтвердить удаление">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="3">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                                    </svg>
                                </button>
                            </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                // Кнопки действий (видны только в режиме администратора)
                if (isAdminMode) {
                    html += `
                        <div class="border-t border-gray-200 my-1"></div>
                        <div class="add-tab-option px-4 py-2 text-sm text-claude-accent hover:bg-gray-100 cursor-pointer transition-colors flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                            </svg>
                            <span>Добавить</span>
                        </div>
                        <div class="edit-tab-option px-4 py-2 text-sm ${isEditMode ? 'text-claude-accent edit-active' : 'text-gray-500 hover:bg-gray-100'} cursor-pointer transition-colors flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                            </svg>
                            <span>${isEditMode ? 'Редактирование ✓' : 'Редактировать'}</span>
                        </div>
                        <div class="export-tab-option px-4 py-2 text-sm text-gray-500 hover:bg-gray-100 cursor-pointer transition-colors flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                            <span>Экспорт</span>
                        </div>
                        <div class="import-tab-option px-4 py-2 text-sm text-gray-500 hover:bg-gray-100 cursor-pointer transition-colors flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                            </svg>
                            <span>Импорт</span>
                        </div>
                    `;
                }
                
                html += '</div>';
                
                menu.innerHTML = html;
                
                // Обработчики для вкладок
                menu.querySelectorAll('.tab-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        // Если клик по кнопкам действий - не переключаем вкладку
                        if (e.target.closest('.tab-actions')) return;
                        
                        // Если есть pending delete и кликнули в другое место - сбрасываем
                        if (pendingDeleteTabId) {
                            pendingDeleteTabId = null;
                            renderTabMenu();
                            return;
                        }
                        
                        const newTab = option.dataset.value;
                        if (currentTab === newTab) {
                            closeMenu();
                            return;
                        }
                        
                        switchToTab(newTab);
                        closeMenu();
                    });
                });
                
                // Обработчики переименования
                menu.querySelectorAll('.tab-rename-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const tabId = btn.dataset.tabId;
                        closeMenu();
                        showRenameTabModal(tabId);
                    });
                });
                
                // Обработчики удаления (первый клик - показать подтверждение)
                menu.querySelectorAll('.tab-delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const tabId = btn.dataset.tabId;
                        pendingDeleteTabId = tabId;
                        renderTabMenu();
                    });
                });
                
                // Обработчики подтверждения удаления
                menu.querySelectorAll('.tab-confirm-delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const tabId = btn.dataset.tabId;
                        
                        if (deleteTab(tabId)) {
                            pendingDeleteTabId = null;
                            // Если удалили текущую вкладку - переключаемся на первую доступную
                            if (currentTab === tabId) {
                                const allTabs = getAllTabs();
                                const firstTab = Object.values(allTabs).sort((a, b) => (a.order || 0) - (b.order || 0))[0];
                                switchToTab(firstTab?.id || 'default');
                            }
                            renderTabMenu();
                            updateSelectedUI();
                        }
                    });
                });
                
                // Обработчик добавления
                menu.querySelector('.add-tab-option')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeMenu();
                    showAddTabModal();
                });
                
                // Обработчик редактирования
                menu.querySelector('.edit-tab-option')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    isEditMode = !isEditMode;
                    toggleEditToolbar(isEditMode);
                    closeMenu();
                    loadPrompts();
                });
                
                // Обработчик экспорта
                menu.querySelector('.export-tab-option')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeMenu();
                    exportConfig();
                });
                
                // Обработчик импорта
                menu.querySelector('.import-tab-option')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeMenu();
                    importConfig();
                });
            }
            
            // Функция обновления выбранного значения в UI
            function updateSelectedUI() {
                const allTabs = getAllTabs();
                const tab = allTabs[currentTab];
                btnText.textContent = tab ? tab.name : 'Default';
            }
            
            // Функция переключения меню
            function toggleMenu() {
                const isOpen = !menu.classList.contains('hidden');
                if (isOpen) {
                    closeMenu();
                } else {
                    // Закрываем меню языка если открыто
                    const langMenu = document.getElementById('language-menu');
                    const langDropdown = document.getElementById('language-dropdown');
                    if (langMenu && !langMenu.classList.contains('hidden')) {
                        langMenu.classList.add('hidden');
                        langDropdown?.classList.remove('open');
                    }
                    
                    pendingDeleteTabId = null; // Сбрасываем состояние подтверждения
                    renderTabMenu();
                    menu.classList.remove('hidden');
                    dropdown.classList.add('open');
                }
            }
            
            // Функция закрытия меню
            function closeMenu() {
                menu.classList.add('hidden');
                dropdown.classList.remove('open');
                pendingDeleteTabId = null; // Сбрасываем состояние подтверждения
            }
            
            // Функция переключения на вкладку
            function switchToTab(newTab) {
                currentTab = newTab;
                localStorage.setItem(TAB_STORAGE_KEY, newTab);
                
                // Сбрасываем режим редактирования
                isEditMode = false;
                toggleEditToolbar(false);
                updateEditTabButton();
                
                // Обновляем UI
                updateSelectedUI();
                
                // Очищаем undo/redo стеки
                undoStack.length = 0;
                redoStack.length = 0;
                updateUndoRedoButtons();
                
                // Перезагружаем промпты
                loadPrompts();
                
                // Сохраняем начальное состояние для undo
                requestAnimationFrame(() => {
                    saveToUndoStack();
                });
            }
            
            // Инициализация UI
            updateSelectedUI();
            
            // Обработчик клика на кнопку
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                toggleMenu();
            });
            
            // Предотвращаем выделение при shift+click
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
            });
            
            // Закрытие по клику вне меню
            document.addEventListener('click', (e) => {
                if (!dropdown.contains(e.target)) {
                    closeMenu();
                }
            });
            
            // Экспортируем функции
            window.updateTabSelectorUI = updateSelectedUI;
            window.switchToTab = switchToTab;
        }
        
        // --- ПАНЕЛЬ ИНСТРУМЕНТОВ РЕДАКТИРОВАНИЯ ---
        
        let activeTextarea = null; // Текущее активное textarea для вставки
        let activeInstructionBlock = null; // Текущий активный блок инструкции для редактирования
        
        function toggleEditToolbar(show) {
            const toolbar = document.getElementById('edit-toolbar');
            if (toolbar) {
                if (show) {
                    toolbar.classList.remove('hidden');
                } else {
                    toolbar.classList.add('hidden');
                }
            }
        }
        
        function showPromptTools() {
            document.getElementById('prompt-tools')?.classList.remove('hidden');
            document.getElementById('instruction-tools')?.classList.add('hidden');
        }
        
        function showInstructionTools() {
            document.getElementById('prompt-tools')?.classList.add('hidden');
            document.getElementById('instruction-tools')?.classList.remove('hidden');
        }
        
        function insertTextAtCursor(text) {
            if (!activeTextarea) return;
            
            // Убеждаемся что textarea в фокусе
            activeTextarea.focus();
            
            // Используем execCommand для поддержки нативного undo/redo
            // Это позволит Ctrl+Z работать внутри textarea
            const success = document.execCommand('insertText', false, text);
            
            // Fallback если execCommand не поддерживается
            if (!success) {
                const start = activeTextarea.selectionStart;
                const end = activeTextarea.selectionEnd;
                const value = activeTextarea.value;
                
                activeTextarea.value = value.substring(0, start) + text + value.substring(end);
                activeTextarea.selectionStart = activeTextarea.selectionEnd = start + text.length;
            }
            
            // Trigger input event для сохранения
            activeTextarea.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Сохраняем в глобальный undo стек (для кнопок)
            saveToUndoStack();
        }
        
        // --- МОДАЛЬНЫЕ ОКНА ДЛЯ ВКЛАДОК ---
        
        // Закрыть все модальные окна
        function closeAllModals() {
            document.querySelectorAll('.modal-overlay').forEach(modal => {
                modal.classList.remove('open');
            });
        }
        
        function showAddTabModal() {
            closeAllModals();
            const modal = document.getElementById('add-tab-modal');
            const input = document.getElementById('new-tab-name');
            if (input) input.value = '';
            modal?.classList.add('open');
            setTimeout(() => input?.focus(), 100);
        }
        
        function hideAddTabModal() {
            document.getElementById('add-tab-modal')?.classList.remove('open');
        }
        
        function showRenameTabModal(tabId) {
            closeAllModals();
            const tabs = getAllTabs();
            const tab = tabs[tabId];
            if (!tab) return;
            
            const modal = document.getElementById('rename-tab-modal');
            const input = document.getElementById('rename-tab-name');
            const hiddenInput = document.getElementById('rename-tab-id');
            if (input) input.value = tab.name;
            if (hiddenInput) hiddenInput.value = tabId;
            modal?.classList.add('open');
            setTimeout(() => input?.focus(), 100);
        }
        
        function hideRenameTabModal() {
            document.getElementById('rename-tab-modal')?.classList.remove('open');
        }
        
        function showDeleteTabModal(tabId) {
            closeAllModals();
            const tabs = getAllTabs();
            const tab = tabs[tabId];
            if (!tab) return;
            
            const modal = document.getElementById('delete-tab-modal');
            const nameSpan = document.getElementById('delete-tab-name');
            const hiddenInput = document.getElementById('delete-tab-id');
            if (nameSpan) nameSpan.textContent = tab.name;
            if (hiddenInput) hiddenInput.value = tabId;
            modal?.classList.add('open');
        }
        
        function hideDeleteTabModal() {
            document.getElementById('delete-tab-modal')?.classList.remove('open');
        }
        
        // --- РЕЖИМ РЕДАКТИРОВАНИЯ ВКЛАДКИ ---
        function toggleEditMode() {
            isEditMode = !isEditMode;
            updateEditTabButton();
            loadPrompts();
        }
        
        function updateEditTabButton() {
            // Функция оставлена для обратной совместимости
            // Кнопка редактирования теперь в выпадающем меню вкладок
        }

        /**
         * Инициализация селектора языка
         */
        function initLanguageSelector() {
            const dropdown = document.getElementById('language-dropdown');
            const btn = document.getElementById('language-btn');
            const btnText = document.getElementById('language-btn-text');
            const menu = document.getElementById('language-menu');
            const options = document.querySelectorAll('.language-option');
            
            // Маппинг значений к текстам
            const langTexts = {
                'bg': 'BG Болгарский',
                'cz': 'CZ Чешский',
                'de': 'DE Немецкий',
                'dk': 'DK Датский',
                'en': 'EN Английский',
                'es': 'ES Испанский',
                'fi': 'FI Финский',
                'fr': 'FR Французский',
                'gr': 'GR Греческий',
                'hr': 'HR Хорватский',
                'hu': 'HU Венгерский',
                'it': 'IT Итальянский',
                'nl': 'NL Голландский',
                'no': 'NO Норвежский',
                'pl': 'PL Польский',
                'pt': 'PT Португальский',
                'ro': 'RO Румынский',
                'se': 'SE Шведский',
                'sk': 'SK Словацкий',
                'sl': 'SL Словенский'
            };
            
            // Функция обновления выбранного значения в UI
            function updateSelectedUI(langCode) {
                btnText.textContent = langTexts[langCode] || langTexts['en'];
                options.forEach(opt => {
                    opt.classList.toggle('selected', opt.dataset.value === langCode);
                });
            }
            
            // Функция переключения меню
            function toggleMenu() {
                const isOpen = !menu.classList.contains('hidden');
                if (isOpen) {
                    menu.classList.add('hidden');
                    dropdown.classList.remove('open');
                } else {
                    // Закрываем меню вкладок если открыто
                    const tabMenu = document.getElementById('tab-menu');
                    const tabDropdown = document.getElementById('tab-dropdown');
                    if (tabMenu && !tabMenu.classList.contains('hidden')) {
                        tabMenu.classList.add('hidden');
                        tabDropdown?.classList.remove('open');
                    }
                    
                    menu.classList.remove('hidden');
                    dropdown.classList.add('open');
                }
            }
            
            // Функция закрытия меню
            function closeMenu() {
                menu.classList.add('hidden');
                dropdown.classList.remove('open');
            }
            
            // Определяем язык из текста промптов (реальный язык в тексте)
            const textLang = detectLanguageFromText();
            
            // Проверяем сохранённый язык в localStorage
            const savedLang = localStorage.getItem(LANGUAGE_STORAGE_KEY);
            
            if (savedLang && LANGUAGES[savedLang]) {
                // Есть сохранённый язык - используем его
                currentLanguage = savedLang;
                updateSelectedUI(savedLang);
            } else {
                // Нет сохранённого языка - определяем из текста
                currentLanguage = textLang;
                updateSelectedUI(textLang);
                localStorage.setItem(LANGUAGE_STORAGE_KEY, textLang);
            }
            
            // Обработчик клика на кнопку
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                toggleMenu();
            });
            
            // Предотвращаем выделение при shift+click
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
            });
            
            // Обработчик клика на опцию
            options.forEach(option => {
                option.addEventListener('click', () => {
                    const newLang = option.dataset.value;
                    
                    if (currentLanguage === newLang) {
                        closeMenu();
                        return;
                    }
                    
                    // Сохраняем старый язык ДО начала замены
                    const oldLang = currentLanguage;
                    
                    // Обновляем UI
                    updateSelectedUI(newLang);
                    closeMenu();
                    
                    // Сохраняем позицию скролла основного контейнера
                    const scrollContainer = document.getElementById('scroll-container');
                    const savedScrollTop = scrollContainer.scrollTop;
                    
                    // Обновляем все textarea - определяем язык каждого блока индивидуально
                    document.querySelectorAll('.textarea-content').forEach(textarea => {
                        // Определяем реальный язык в этом конкретном блоке
                        // Если не можем определить - используем oldLang (язык ДО переключения)
                        const blockLang = detectLanguageInText(textarea.value) || oldLang;
                        
                        if (blockLang !== newLang) {
                            textarea.value = replaceLanguage(textarea.value, blockLang, newLang);
                            autoResizeTextarea(textarea);
                            
                            // Сохраняем СРАЗУ (без debounce) при смене языка
                            const itemId = textarea.dataset.itemId;
                            saveToLocalStorage(itemId, textarea.value);
                        }
                    });
                    
                    // Восстанавливаем позицию скролла
                    scrollContainer.scrollTop = savedScrollTop;
                    
                    // Обновляем currentLanguage после замены
                    currentLanguage = newLang;
                    localStorage.setItem(LANGUAGE_STORAGE_KEY, newLang);
                    
                    // Сохраняем состояние в undo стек
                    saveToUndoStack();
                    
                    showLanguageToast(LANGUAGES[newLang].name);
                });
            });
            
            // Закрытие по клику вне меню
            let isDraggingScrollbar = false;
            
            document.addEventListener('click', (e) => {
                if (isDraggingScrollbar) {
                    isDraggingScrollbar = false;
                    return;
                }
                if (!dropdown.contains(e.target)) {
                    closeMenu();
                }
            });
            
            // Кастомный скроллбар для меню
            const scrollbar = document.getElementById('lang-scrollbar');
            const menuInner = document.getElementById('language-menu-inner');
            const thumb = scrollbar.querySelector('.lang-menu-scrollbar-thumb');
            
            function updateMenuScrollbar() {
                const scrollHeight = menuInner.scrollHeight;
                const clientHeight = menuInner.clientHeight;
                const trackHeight = scrollbar.clientHeight;
                
                if (scrollHeight <= clientHeight) {
                    scrollbar.style.opacity = '0';
                    return;
                }
                scrollbar.style.opacity = '1';
                
                const thumbHeight = Math.max(20, (clientHeight / scrollHeight) * trackHeight);
                const maxScroll = scrollHeight - clientHeight;
                const scrollPercent = menuInner.scrollTop / maxScroll;
                const thumbTop = scrollPercent * (trackHeight - thumbHeight);
                
                thumb.style.height = thumbHeight + 'px';
                thumb.style.top = thumbTop + 'px';
            }
            
            menuInner.addEventListener('scroll', updateMenuScrollbar);
            
            // Drag functionality для ползунка
            let isDragging = false;
            let startY = 0;
            let startScrollTop = 0;
            
            thumb.addEventListener('mousedown', (e) => {
                isDragging = true;
                isDraggingScrollbar = true;
                startY = e.clientY;
                startScrollTop = menuInner.scrollTop;
                thumb.classList.add('dragging');
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaY = e.clientY - startY;
                const trackHeight = scrollbar.clientHeight;
                const thumbHeight = thumb.clientHeight;
                const scrollHeight = menuInner.scrollHeight;
                const clientHeight = menuInner.clientHeight;
                const maxScroll = scrollHeight - clientHeight;
                
                const scrollRatio = maxScroll / (trackHeight - thumbHeight);
                menuInner.scrollTop = startScrollTop + deltaY * scrollRatio;
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    thumb.classList.remove('dragging');
                    // Сбрасываем флаг с небольшой задержкой, чтобы click не сработал
                    setTimeout(() => {
                        isDraggingScrollbar = false;
                    }, 10);
                }
            });
            
            // Обновляем при открытии меню
            const origToggle = toggleMenu;
            toggleMenu = function() {
                const wasHidden = menu.classList.contains('hidden');
                origToggle();
                if (wasHidden) {
                    setTimeout(updateMenuScrollbar, 10);
                }
            };
        }

        /**
         * Показывает уведомление о смене языка
         */
        function showLanguageToast(langName) {
            const toast = document.getElementById('toast');
            toast.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                </svg>
                Язык изменён: ${langName}
            `;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
                // Возвращаем исходный текст
                toast.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                    </svg>
                    Скопировано в буфер
                `;
            }, 2500);
        }

        // Исходный шаблон контента
        const PROMPTS_DATA = [
            { number: "1", title: "Контент-план", content: `Твоя задача — создать контент-план для pillar-страницы по ключевому слову "example" в тематике спортивных ставок в контексте example.

1. Анализ и сбор данных
Проанализируй ТОП-10 поисковой выдачи в англоязычном сегменте по этому ключу.
Определи интенты пользователей (информационный, навигационный, коммерческий, смешанный).
Определи структуру и глубину проработки тем у конкурентов.

2. Создание контент плана
На основании анализа напиши контент-план на английском языке для pillar-статьи. Также сформулируй 5 кластерных страниц отдельно, после основной pillar статьи. Формат markdown.

Будущие статьи по твоему контент-плану должны соответствовать этим требованиям:

3. Семантическое ядро
Возьми ключевой запрос как основу.
Найди популярные средне- и высокочастотные интентные запросы через анализ поисковых данных.
Добавь LSI-фразы, синонимы и смежные формулировки.
Раздели ключи по смысловым кластерам (основные, вспомогательные, уточняющие).
В тексте используй их органично, без переспама.

4. Подбор вопросов
Найди 5–10 популярных вопросов пользователей по теме на основе:
"Похожие вопросы" в поисковых системах.
People Also Ask (Google).
на тематических форумах.
Из них выбери 3 самых релевантных для финального FAQ.

5. Требования к pillar-статье
Объем: 5000-6000 слов.
Стиль: технический, повествовательный, но лёгкий для восприятия.
Пиши как человек, без воды, с уместной долей иронии.
Минимум подзаголовков, максимум раскрытия темы.
Под каждым подзаголовком — не менее 3 содержательных абзацев.
Не более 2 ненумерованных списков и только там, где они реально нужны.
Используй Markdown-разметку для заголовков, списков и выделений.
Навигацию по странице делай через обычный table of contents.
Хедер должен быть стандартным, в начале страницы без доп. контейнеров, отдельным элементом.
Текста должно быть от 70%, списков до 30% всего визуального объёма статьи.

6. Требования к кластерным статьям
Объем каждой статьи: 3000-4000 слов.
Стиль: технический, повествовательный, но лёгкий для восприятия.
Пиши как человек, без воды, с уместной долей иронии.
Минимум подзаголовков, максимум раскрытия темы.
Под каждым подзаголовком — не менее 3 содержательных абзацев.
Не более 2 ненумерованных списков и только там, где они реально нужны.
Используй Markdown-разметку для заголовков, списков и выделений.
НЕ СОЗДАВАЙ блоки по типу: плюсы/минусы, цитаты в рамках, faq.
Текста должно быть от 70%, списков до 30% всего визуального объёма статей.

7. SEO-настройка текста
Внедряй ключи и LSI-слова органично.
Оптимизируй под голосовой поиск и фичерные сниппеты.
При необходимости, предложи микроразметку (FAQ, Article).

8. Завершение
Заверши статью секцией FAQ (3 вопроса-ответа).

После сохранения markdown-файла — отдельно напиши:
• Title для SEO (до 70 символов)
• Description для SEO (до 160 символов)

НЕ вставляй мета-теги в сам markdown-файл.`, instruction: {"type": "input", "icon": "edit", "text": "Заменить ключевое слово и контекст", "fields": [{"label": "Ключевое слово", "placeholder": "", "prefix": "по ключевому слову", "optional": false}, {"label": "Контекст", "placeholder": "", "prefix": "в контексте", "optional": true}]} },
            { number: "2", title: "Pillar - статья", content: `Теперь, используя дополнительно твои знания о хуманизации, напиши максимально очеловеченный текст для главной pillar-статьи на английском языке для английской аудитории. Текста должно быть от 70%, списков до 30% всего визуального объёма статьи.

═══════════════════════════════════════════════════════════════════
КОНТРОЛЬ ОБЪЁМА ТЕКСТА
═══════════════════════════════════════════════════════════════════

Целевой диапазон: 5000-6000 слов.

ПЕРЕД началом написания создай таблицу планирования:

| Секция | Планируемый объём |
|--------|-------------------|
| Введение | 400-500 слов |
| Секция 1 | ... слов |
| Секция 2 | ... слов |
| ... | ... |
| Заключение | 300-400 слов |
| FAQ | 250-350 слов |
| ИТОГО | 5000-6000 слов |

═══════════════════════════════════════════════════════════════════
СТРУКТУРА И ФОРМАТИРОВАНИЕ
═══════════════════════════════════════════════════════════════════

- Убедись, что создал table of contents
- Минимум подзаголовков, максимум раскрытия темы
- Под каждым подзаголовком — не менее 3 содержательных абзацев
- Не более 2 ненумерованных списков и только там, где они реально нужны
- Используй Markdown-разметку для заголовков, списков и выделений
- Навигацию по странице делай через обычный table of contents
- Хедер должен быть стандартным, в начале страницы без доп. контейнеров

═══════════════════════════════════════════════════════════════════
ВАЖНЫЕ ОГРАНИЧЕНИЯ
═══════════════════════════════════════════════════════════════════

- КРИТИЧЕСКИ ВАЖНО: не используй в тексте никаких языков, кроме английского

ЗАПРЕЩЕНО в тексте статьи:
- Эмодзи
- Выдуманные внешние ссылки и placeholder-ссылки (example.com и т.п.)
- Перекрёстные ссылки на другие статьи проекта
- Ссылки на несуществующие ресурсы

РАЗРЕШЕНО:
- Ссылки на реальные авторитетные источники (только если действительно необходимы)

После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, фактические. Используй веб-поиск. Исправь при обнаружении.

- Сохрани pillar-статью в отдельный .md файл с названием index`, instruction: null },
            { number: "3", title: "Pillar-дизайн", content: `Role: You are an expert-level Web Designer and Front-End Developer who champions semantic HTML, accessibility (a11y), and web performance. Your primary mission is to create interfaces that are not just beautiful, but meaningful, fast, and universally understandable by both humans and machines.
Create a modern, visually appealing, and semantically correct HTML design based on the provided text content.
Mandatory Structure Requirements:
Semantic Markup:

Use ONLY ONE <main> tag for the primary content
Use ONLY ONE main <header> inside <main> with <h1> and a brief introductory paragraph
Use ONLY ONE main <footer> after <main>
Wrap each logical section under <h2> headings in <section> tags
Use <article> for self-contained content
Use <aside> for supplementary information (author, ads, related content)
Use <time> for all dates with datetime attribute
Use <nav> for navigation elements
Use semantic tags instead of divs wherever possible: <figure>, <figcaption>, <blockquote>, <cite>, <mark>, <details>, <summary>

Performance Optimization:

Minimize DOM nesting (maximum 3-4 levels where possible)
Aim for total DOM nodes under 900
Avoid "div soup" - every element should have semantic meaning
Use CSS Grid and Flexbox for layout instead of multiple wrappers
Apply CSS variables for repeated values

Visual Design:

Create a modern, attractive design with:

Smooth hover animations (use transform and opacity for GPU acceleration)
Responsive typography with clamp() for fluid scaling
Subtle shadows and gradients for depth
Accent colors for important elements
Micro-animations for interactive elements


Ensure excellent readability with proper spacing and line heights
Add dark theme support via CSS variables and prefers-color-scheme

Accessibility and Resilience:

Document must be fully readable without CSS and JavaScript
Use proper heading hierarchy (h1 → h2 → h3, no skipping)
Add aria-labels where necessary for screen readers
Ensure contrast ratio of at least 4.5:1 for regular text
Add :focus styles for keyboard navigation

Machine Readability:

Structure content to be understandable by search engines and AI agents
Group related content semantically close in the DOM
Use Schema.org microdata where appropriate

Technical Details:

All code in a single HTML file
Use modern CSS (Grid, Flexbox, Custom Properties, clamp())
Add smooth transitions for all interactive elements
Include meta tags for SEO and social media
Make design fully responsive (mobile-first approach)

Final Result:
Create a fully functional, beautiful, and semantically correct HTML document that:

Looks visually stunning
Loads and renders quickly
Is accessible to all users
Is easily parsed by machines and AI
Maintains functionality even with styles disabled

DON'T put any emojis anywhere
Save it as a separate design.html file`, instruction: null },
            { number: "4", title: "Кластерные статьи", content: `Теперь, используя все твои знания о хуманизации, напиши максимально очеловеченный текст на английском языке для английской аудитории для первых двух кластерных статей. Сохрани их в отдельные .md файлы и именуй по принципу index1, index2, index3 и т.д. Не затягивай текст в код. Текста должно быть от 70%, списков до 30% всего визуального объёма каждой отдельной статьи. Жирного шрифта не более 20%.
Не добавляй оглавления и разделители между частями статей.
Целевой диапазон: 3000-4000 слов.
НЕ генерируй FAQ. КРИТИЧЕСКИ ВАЖНО: не используй в тексте никаких языков, кроме английского.

ЗАПРЕЩЕНО в тексте статьи:
- Эмодзи
- Выдуманные внешние ссылки и placeholder-ссылки (example.com и т.п.)
- Перекрёстные ссылки на другие статьи проекта
- Ссылки на несуществующие ресурсы

РАЗРЕШЕНО:
- Ссылки на реальные авторитетные источники (только если действительно необходимы)

После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, фактические. Используй веб-поиск. Исправь при обнаружении.`, instruction: null },
            { number: "5", title: "Кластеры - код и изображения", content: `Обрабатывай только кластерные статьи index1-5.md (НЕ трогай index.md и design.html).
Сейчас сделай только index1.md и index2.md.

Ты — опытный эксперт по HTML-вёрстке и генерации промтов для изображений.

═══════════════════════════════════════════════════════════════════
ЯЗЫК И КОДИРОВКА
═══════════════════════════════════════════════════════════════════
КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для английского:
Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию

═══════════════════════════════════════════════════════════════════
ЗАДАЧА
═══════════════════════════════════════════════════════════════════
Для каждого .md файла:
1. Конвертируй Markdown в HTML
2. Интегрируй 6 изображений
3. Создай промты для генерации изображений

Текст переноси СЛОВО В СЛОВО. Не сокращай, не перефразируй.

═══════════════════════════════════════════════════════════════════
HTML
═══════════════════════════════════════════════════════════════════
Создай чистый HTML без CSS, без стилей, без классов.
Структура: <!DOCTYPE html>, <html>, <head> с meta charset и viewport, <body>, <article>.
Вставь ровно 6 тегов <img>:
- Hero (первое): без loading="lazy"
- Остальные 2-6: с loading="lazy"
- Формат: только .webp
- Alt-теги: на языке статьи

Никаких эмодзи.

═══════════════════════════════════════════════════════════════════
ИЗОБРАЖЕНИЯ
═══════════════════════════════════════════════════════════════════

Общие требования:
- Ровно 6 изображений на страницу
- Реалистичные или гиперреалистичные
- Понятные с первого взгляда
- Логично соответствуют теме секции
- Без абстракции и футуризма
- Alt-теги и текст внутри изображений — на языке страницы
- Ничего не обрезано

Категорически запрещено:
- Абстрактные и футуристичные сцены
- Нереалистичные формы и пропорции
- Калькуляторы
- Календари
- Реальные деньги и банковские карты

Обязательные замены:
- Калькулятор → человек считает / документ / простой график без цифр
- Календарь → планирование / таймлайн / блокнот (не сетка)
- Деньги → символические знаки (€ / $)

Hero-изображение (№1):
- Один главный объект или простая сцена
- Сильное визуальное впечатление (свет, композиция)
- Без графиков, таблиц, KPI и интерфейсов
- Допустим короткий заголовок на языке страницы
- Ничего не обрезано

Остальные изображения (2–6):
- Допускаются простые визуализации, аккуратные графики и чистые интерфейсы

СПОРТ (для спортивных страниц):
- В промптах явно обозначь вид спорта на основе контекста статьи
- Указывай: тип поля/покрытия, корректный инвентарь, корректную экипировку

═══════════════════════════════════════════════════════════════════
ФОРМАТ ВЫВОДА
═══════════════════════════════════════════════════════════════════

Для каждой статьи создай 2 файла:

1. index[N].html — HTML с 6 изображениями
2. prompts[N].txt — для каждого изображения: промт, имя файла (.webp), размер (px), место в тексте

Именование: сохраняй исходные имена файлов. Не переименовывай по порядку обработки.

═══════════════════════════════════════════════════════════════════
ПЕРЕД СОХРАНЕНИЕМ
═══════════════════════════════════════════════════════════════════
Посчитай теги <img> в HTML. Если их не ровно 6 — исправь.`, instruction: {"type": "info", "text": "Прикрепить index1.md, index2.md, index3.md, index4.md, index5.md", "icon": "paperclip"} },
            { number: "6", title: "Pillar - код и изображения", content: `Ты — опытный UI-дизайнер и эксперт по HTML-вёрстке и генерации промтов для изображений.

═══════════════════════════════════════════════════════════════════
ВХОДНЫЕ ДАННЫЕ
═══════════════════════════════════════════════════════════════════
- index.md — текст статьи
- design.html — дизайн-шаблон

═══════════════════════════════════════════════════════════════════
ЯЗЫК И КОДИРОВКА
═══════════════════════════════════════════════════════════════════
КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для английского:
Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию

═══════════════════════════════════════════════════════════════════
ЗАДАЧА
═══════════════════════════════════════════════════════════════════
1. Возьми ВЕСЬ текст из index.md
2. Оберни в дизайн из design.html
3. Интегрируй 6 изображений
4. Создай CSS для изображений
5. Создай промты для генерации изображений

Текст переноси СЛОВО В СЛОВО. Не сокращай, не перефразируй.

═══════════════════════════════════════════════════════════════════
HTML
═══════════════════════════════════════════════════════════════════
Конвертируй Markdown в HTML.
Применяй дизайн из design.html.

Вставь ровно 6 тегов <img>:
- Hero (первое): без loading="lazy"
- Остальные 2-6: с loading="lazy"
- Формат: только .webp
- Alt-теги: на языке статьи

Никаких эмодзи.

Разбиение на артефакты:
Файл большой — разбивай на 3 артефакта, затем объедини в один index.html.

═══════════════════════════════════════════════════════════════════
CSS
═══════════════════════════════════════════════════════════════════
Создай images-styles.css:
- Адаптивность для desktop/mobile
- Hover-эффекты
- Мягкие анимации

═══════════════════════════════════════════════════════════════════
ИЗОБРАЖЕНИЯ
═══════════════════════════════════════════════════════════════════

Общие требования:
- Ровно 6 изображений на страницу
- Реалистичные или гиперреалистичные
- Понятные с первого взгляда
- Логично соответствуют теме секции
- Без абстракции и футуризма
- Alt-теги и текст внутри изображений — на языке страницы
- Ничего не обрезано

Категорически запрещено:
- Абстрактные и футуристичные сцены
- Нереалистичные формы и пропорции
- Калькуляторы
- Календари
- Реальные деньги и банковские карты

Обязательные замены:
- Калькулятор → человек считает / документ / простой график без цифр
- Календарь → планирование / таймлайн / блокнот (не сетка)
- Деньги → символические знаки (€ / $)

Hero-изображение (№1):
- Один главный объект или простая сцена
- Сильное визуальное впечатление (свет, композиция)
- Без графиков, таблиц, KPI и интерфейсов
- Допустим короткий заголовок на языке страницы
- Ничего не обрезано

Остальные изображения (2–6):
- Допускаются простые визуализации, аккуратные графики и чистые интерфейсы

СПОРТ (для спортивных страниц):
- В промптах явно обозначь вид спорта на основе контекста статьи
- Указывай: тип поля/покрытия, корректный инвентарь, корректную экипировку

═══════════════════════════════════════════════════════════════════
ФОРМАТ ВЫВОДА
═══════════════════════════════════════════════════════════════════

Создай 3 файла:

1. index.html — HTML с дизайном и 6 изображениями
2. images-styles.css — стили для изображений
3. prompts.txt — для каждого изображения: промт, имя файла (.webp), размер (px), место в тексте

═══════════════════════════════════════════════════════════════════
ПЕРЕД СОХРАНЕНИЕМ
═══════════════════════════════════════════════════════════════════
Посчитай теги <img> в HTML. Если их не ровно 6 — исправь.`, instruction: {"type": "info", "text": "Прикрепить index.md и design.html", "icon": "paperclip"} },
            { number: "7", title: "Технические страницы", content: `Войди в роль опытного SEO-копирайтера и редактора с глубоким знанием английского языка, маркетинга и поисковой оптимизации. 

Проанализируй сайт в index.html, затем указанные ниже страницы и напиши аналогичные для этого сайта на английском языке для англоязычной аудитории. Не нумеруй подразделы. Не используй эмодзи. Не вставляй placeholder ссылки или почтовые адреса, по типу "example.com" или "@example.com". Затягивай готовую страницу сразу в HTML. ГЕНЕРИРУЙ только чистый контент с простыми списками без классов, c основным текстом внутри тега article.
Генерируй мета тайтл/деск для страниц в начале. 
НЕ генерируй стилей.

ЗАПРЕЩЕНО:
- Любые placeholder-ссылки (example.com, yoursite.com, tudominio.com и т.п.)
- Выдуманные email-адреса (info@example.com, contact@company.com и т.п.)
- Выдуманные телефоны и адреса офисов
- Любые заглушки, которые подразумевают замену

РАЗРЕШЕНО:
- Ссылки на реальные официальные сайты (законодательство страны, регуляторы азартных игр и т.п.)
- Страницы без контактных данных — это нормально для данного типа сайтов

У тебя должно получиться четыре страницы.

ПЕРВАЯ СТРАНИЦА:

Privacy Policy
https://www.sportwettenvergleich.net/datenschutz/
https://sportwettenschweiz.pro/datenschutz/
https://sport-oesterreich.at/datenschutz/
https://sportwetten-helden.com/datenschutzerklarung/
https://sportwettenschweiz.com/datenschutzrichtlinie/
https://www.vanguardngr.com/casino/de/datenschutz/
https://sportwetten-online.com/datenschutzerklaerung
https://schweizerwettanbieter.com/datenschutzerklaerung/
https://www.wettenoesterreich.at/datenschutzerklaerung/
https://wettformat.com/at/datenschutzerklaerung
https://www.sportwettentest.net/datenschutz/
https://www.wettanbieter.de/datenschutz/
https://www.transfermarkt.de/sportwetten/datenschutzhinweis/
https://www.wettanbieter.org/datenschutz/
https://www.wettbuero.de/disclaimer/

---------------------------------------------------

ВТОРАЯ СТРАНИЦА:

About Us
https://www.sportwettenvergleich.net/ueber-uns/
https://www.sportwettenoesterreich.at/ueber-uns.html
https://sportwettenschweiz.pro/about/
https://sportwetten-helden.com/ueber-uns/
https://sportwettenschweiz.com/uber-uns/
https://sportwettenschweiz.ch/uber-uns/
https://www.vanguardngr.com/casino/de/uber-uns/
https://www.wettenoesterreich.at/ueber-uns/
https://www.wett-bonus.com/ueber-uns/
https://wettformat.com/at/ueber-uns
https://www.sportwettentest.net/about/
https://www.wettanbieter.de/autoren/
https://www.wettanbieter.org/ueber-uns/

---------------------------------------------------

ТРЕТЬЯ СТРАНИЦА:

Legal Information
https://www.sportwettenvergleich.net/impressum/
https://sportwettenschweiz.pro/impressum/
https://sport-oesterreich.at/impressum/
https://sportwetten-helden.com/impressum/
https://sportwetten-online.com/impressum
https://wettformat.com/at/impressum
https://www.sportwettentest.net/impressum/
https://www.wettanbieter.de/impressum/
https://www.transfermarkt.de/sportwetten/impressum/
https://www.wettbasis.com/impressum
https://www.wettbuero.de/impressum/

---------------------------------------------------

ЧЕТВЁРТАЯ СТРАНИЦА:

Cookie Policy
https://sportwettenschweiz.pro/cookie-richtlinien/
https://sportwetten-helden.com/eu-cookie-richtlinien/
https://wettformat.com/at/cookie-richtlinie
https://www.sportwettentest.net/cookie-richtlinie/
https://www.wettanbieter.de/cookie-policy/
https://www.transfermarkt.de/sportwetten/cookie-policy-eu/
https://www.wettbasis.com/cookie-richtlinie
https://www.sportwettenvergleich.net/cookie-policy/
https://sportwetten-magazin.com/cookie-policy/
https://www.sportwetten-community.de/cookie-richtlinie-eu`, instruction: null }
        ];



        // Данные для вкладки CLUSTERS-PICS (кластерные статьи)
        const PROMPTS_DATA_TASK4 = [
            { number: "1", title: "Анализ + Контент-план", content: `Ты — опытный SEO-специалист.

═══════════════════════════════════════════════════════════════════
ВХОДНЫЕ ДАННЫЕ
═══════════════════════════════════════════════════════════════════
HTML-файл pillar-страницы

═══════════════════════════════════════════════════════════════════
ЗАДАЧА
═══════════════════════════════════════════════════════════════════

ШАГ 1: АНАЛИЗ
- Определи тематику pillar-страницы
- Проанализируй ТОП-10 конкурентов в поисковой выдаче
- Определи интенты пользователей
- Определи структуру и глубину проработки тем у конкурентов

ШАГ 2: КОНТЕНТ-ПЛАН
На основе анализа составь контент-план на 30 кластерных статей на английском языке.

Для каждой статьи укажи:
- Название
- Целевой ключевой запрос
- Краткое описание (1-2 предложения)

═══════════════════════════════════════════════════════════════════
ФОРМАТ ВЫВОДА
═══════════════════════════════════════════════════════════════════
Сохрани контент-план в файл content-plan.md` },
            { number: "2", title: "Написание статей", content: `Напиши кластерные статьи №1-5 по контент-плану.

═══════════════════════════════════════════════════════════════════
ТРЕБОВАНИЯ К СТАТЬЯМ
═══════════════════════════════════════════════════════════════════
- Целевой диапазон: 1200-2000 слов
- Язык: английский
- Стиль: технический, повествовательный, но лёгкий для восприятия
- Пиши как человек, без воды, с уместной долей иронии
- Минимум подзаголовков, максимум раскрытия темы
- Под каждым подзаголовком — не менее 3 содержательных абзацев
- Не более 2 ненумерованных списков
- Текста от 70%, списков до 30% общего визуального объёма статьи
- Жирного шрифта до 10% общего визуального объёма статьи
- Используй Markdown-разметку

ЗАПРЕЩЕНО:
- Эмодзи
- Блоки плюсы/минусы
- Цитаты в рамках
- FAQ
- Выдуманные и placeholder-ссылки

═══════════════════════════════════════════════════════════════════
ФОРМАТ ВЫВОДА
═══════════════════════════════════════════════════════════════════
Сохрани каждую статью в отдельный .md файл: index1.md, index2.md и т.д.

После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, фактические. Используй веб-поиск. Исправь при обнаружении.` },
            { number: "3", title: "HTML + картинки", content: `Конвертируй статьи index1-5.md в HTML и создай промпты для изображений.

Ты — опытный эксперт по HTML-вёрстке и генерации промтов для изображений.

═══════════════════════════════════════════════════════════════════
ЯЗЫК И КОДИРОВКА
═══════════════════════════════════════════════════════════════════
КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для английского:
Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию

═══════════════════════════════════════════════════════════════════
ЗАДАЧА
═══════════════════════════════════════════════════════════════════
Для каждого .md файла:
1. Конвертируй Markdown в HTML
2. Интегрируй 3 изображения
3. Создай промты для генерации изображений

Текст переноси СЛОВО В СЛОВО. Не сокращай, не перефразируй.

═══════════════════════════════════════════════════════════════════
HTML
═══════════════════════════════════════════════════════════════════
Создай чистый HTML без CSS, без стилей, без классов.
Структура: <!DOCTYPE html>, <html>, <head> с meta charset и viewport, <body>, <article>.

Вставь ровно 3 тега <img>:
- Hero (первое): без loading="lazy"
- Остальные 2-3: с loading="lazy"
- Формат: только .webp
- Alt-теги: на языке статьи

Никаких эмодзи.

═══════════════════════════════════════════════════════════════════
ИЗОБРАЖЕНИЯ
═══════════════════════════════════════════════════════════════════

Общие требования:
- Ровно 3 изображения на страницу
- Реалистичные или гиперреалистичные
- Понятные с первого взгляда
- Логично соответствуют теме секции
- Без абстракции и футуризма
- Alt-теги и текст внутри изображений — на языке страницы
- Ничего не обрезано

Категорически запрещено:
- Абстрактные и футуристичные сцены
- Нереалистичные формы и пропорции
- Калькуляторы
- Календари
- Реальные деньги и банковские карты

Обязательные замены:
- Калькулятор → человек считает / документ / простой график без цифр
- Календарь → планирование / таймлайн / блокнот (не сетка)
- Деньги → символические знаки (€ / $)

Hero-изображение (№1):
- Один главный объект или простая сцена
- Сильное визуальное впечатление (свет, композиция)
- Без графиков, таблиц, KPI и интерфейсов
- Допустим короткий заголовок на языке страницы
- Ничего не обрезано

Остальные изображения (2-3):
- Допускаются простые визуализации, аккуратные графики и чистые интерфейсы

СПОРТ (для спортивных страниц):
- В промптах явно обозначь вид спорта на основе контекста статьи
- Указывай: тип поля/покрытия, корректный инвентарь, корректную экипировку

═══════════════════════════════════════════════════════════════════
ФОРМАТ ВЫВОДА
═══════════════════════════════════════════════════════════════════

Для каждой статьи создай 2 файла:

1. index[N].html — HTML с 3 изображениями
2. prompts[N].txt — для каждого изображения: промт, имя файла (.webp), размер (px), место в тексте

Именование: сохраняй исходные имена файлов. Не переименовывай по порядку обработки.

═══════════════════════════════════════════════════════════════════
ПЕРЕД СОХРАНЕНИЕМ
═══════════════════════════════════════════════════════════════════
Посчитай теги <img> в HTML. Если их не ровно 3 — исправь.`, instruction: { type: "info", text: "Добавить файлы index1-30.md в чат" } }
        ];
        
        // Данные для вкладки ADAPTATION (адаптация контента)
        const PROMPTS_DATA_TASK2 = [
            { number: "1", title: "Контент-план", content: `Твоя задача — создать контент-план для pillar-страницы по ключевому слову "example" в тематике спортивных ставок.
Список ключей для кластерных статей:
example

1. Анализ и сбор данных
Проанализируй ТОП-10 поисковой выдачи в англоязычном сегменте по этому ключу.
Определи интенты пользователей (информационный, навигационный, коммерческий, смешанный).
Определи структуру и глубину проработки тем у конкурентов.

2. Создание контент плана
На основании анализа напиши контент-план на английском языке для pillar-статьи. Также сформулируй кластерные страницы по списку ключей (один ключ - одна кластерная статья), после основной pillar статьи. Формат markdown.

Будущие статьи по твоему контент-плану должны соответствовать этим требованиям:

3. Семантическое ядро
Возьми ключевой запрос как основу.
Найди популярные средне- и высокочастотные интентные запросы через анализ поисковых данных.
Добавь LSI-фразы, синонимы и смежные формулировки.
Раздели ключи по смысловым кластерам (основные, вспомогательные, уточняющие).
В тексте используй их органично, без переспама.

4. Подбор вопросов
Найди 5–10 популярных вопросов пользователей по теме на основе:
"Похожие вопросы" в поисковых системах.
People Also Ask (Google).
на тематических форумах.
Из них выбери 3 самых релевантных для финального FAQ.

5. Требования к pillar-статье
Объем: 5000-6000 слов.
Стиль: технический, повествовательный, но лёгкий для восприятия.
Пиши как человек, без воды, с уместной долей иронии.
Минимум подзаголовков, максимум раскрытия темы.
Под каждым подзаголовком — не менее 3 содержательных абзацев.
Не более 2 ненумерованных списков и только там, где они реально нужны.
Используй Markdown-разметку для заголовков, списков и выделений.
Навигацию по странице делай через обычный table of contents.
Хедер должен быть стандартным, в начале страницы без доп. контейнеров, отдельным элементом.
Текста должно быть от 70%, списков до 30% всего визуального объёма статьи.

6. Требования к кластерным статьям
Объем каждой статьи: 3000-4000 слов.
Стиль: технический, повествовательный, но лёгкий для восприятия.
Пиши как человек, без воды, с уместной долей иронии.
Минимум подзаголовков, максимум раскрытия темы.
Под каждым подзаголовком — не менее 3 содержательных абзацев.
Не более 2 ненумерованных списков и только там, где они реально нужны.
Используй Markdown-разметку для заголовков, списков и выделений.
НЕ СОЗДАВАЙ блоки по типу: плюсы/минусы, цитаты в рамках, faq.
Текста должно быть от 70%, списков до 30% всего визуального объёма статей.

7. SEO-настройка текста
Внедряй ключи и LSI-слова органично.
Оптимизируй под голосовой поиск и фичерные сниппеты.
При необходимости, предложи микроразметку (FAQ, Article).

8. Завершение
Заверши статью секцией FAQ (3 вопроса-ответа).

После сохранения markdown-файла — отдельно напиши:
• Title для SEO (до 70 символов)
• Description для SEO (до 160 символов)

НЕ вставляй мета-теги в сам markdown-файл.`, instruction: {"type": "input", "icon": "edit", "text": "Заменить ключевое слово", "fields": [{"label": "Ключевое слово", "placeholder": "", "prefix": "по ключевому слову \"", "optional": false}]} },
            { number: "2", title: "Pillar - статья", content: `Теперь, используя дополнительно твои знания о хуманизации, напиши максимально очеловеченный текст для главной pillar-статьи на английском языке для английской аудитории. Текста должно быть от 70%, списков до 30% всего визуального объёма статьи.

═══════════════════════════════════════════════════════════════════
КОНТРОЛЬ ОБЪЁМА ТЕКСТА
═══════════════════════════════════════════════════════════════════

Целевой диапазон: 5000-6000 слов.

ПЕРЕД началом написания создай таблицу планирования:

| Секция | Планируемый объём |
|--------|-------------------|
| Введение | 400-500 слов |
| Секция 1 | ... слов |
| Секция 2 | ... слов |
| ... | ... |
| Заключение | 300-400 слов |
| FAQ | 250-350 слов |
| ИТОГО | 5000-6000 слов |

═══════════════════════════════════════════════════════════════════
СТРУКТУРА И ФОРМАТИРОВАНИЕ
═══════════════════════════════════════════════════════════════════

- Убедись, что создал table of contents
- Минимум подзаголовков, максимум раскрытия темы
- Под каждым подзаголовком — не менее 3 содержательных абзацев
- Не более 2 ненумерованных списков и только там, где они реально нужны
- Используй Markdown-разметку для заголовков, списков и выделений
- Навигацию по странице делай через обычный table of contents
- Хедер должен быть стандартным, в начале страницы без доп. контейнеров

═══════════════════════════════════════════════════════════════════
ВАЖНЫЕ ОГРАНИЧЕНИЯ
═══════════════════════════════════════════════════════════════════

- КРИТИЧЕСКИ ВАЖНО: не используй в тексте никаких языков, кроме английского

ЗАПРЕЩЕНО в тексте статьи:
- Эмодзи
- Выдуманные внешние ссылки и placeholder-ссылки (example.com и т.п.)
- Перекрёстные ссылки на другие статьи проекта
- Ссылки на несуществующие ресурсы

РАЗРЕШЕНО:
- Ссылки на реальные авторитетные источники (только если действительно необходимы)

После написания статьи выполни проверку на ошибки: орфографические, пунктуационные, фактические. Используй веб-поиск. Исправь при обнаружении.

- Сохрани pillar-статью в отдельный .md файл с названием index` },
            { number: "3", title: "Pillar-дизайн", content: `Role: You are an expert-level Web Designer and Front-End Developer who champions semantic HTML, accessibility (a11y), and web performance. Your primary mission is to create interfaces that are not just beautiful, but meaningful, fast, and universally understandable by both humans and machines.
Create a modern, visually appealing, and semantically correct HTML design based on the provided text content.
Mandatory Structure Requirements:
Semantic Markup:

Use ONLY ONE <main> tag for the primary content
Use ONLY ONE main <header> inside <main> with <h1> and a brief introductory paragraph
Use ONLY ONE main <footer> after <main>
Wrap each logical section under <h2> headings in <section> tags
Use <article> for self-contained content
Use <aside> for supplementary information (author, ads, related content)
Use <time> for all dates with datetime attribute
Use <nav> for navigation elements
Use semantic tags instead of divs wherever possible: <figure>, <figcaption>, <blockquote>, <cite>, <mark>, <details>, <summary>

Performance Optimization:

Minimize DOM nesting (maximum 3-4 levels where possible)
Aim for total DOM nodes under 900
Avoid "div soup" - every element should have semantic meaning
Use CSS Grid and Flexbox for layout instead of multiple wrappers
Apply CSS variables for repeated values

Visual Design:

Create a modern, attractive design with:

Smooth hover animations (use transform and opacity for GPU acceleration)
Responsive typography with clamp() for fluid scaling
Subtle shadows and gradients for depth
Accent colors for important elements
Micro-animations for interactive elements


Ensure excellent readability with proper spacing and line heights
Add dark theme support via CSS variables and prefers-color-scheme

Accessibility and Resilience:

Document must be fully readable without CSS and JavaScript
Use proper heading hierarchy (h1 → h2 → h3, no skipping)
Add aria-labels where necessary for screen readers
Ensure contrast ratio of at least 4.5:1 for regular text
Add :focus styles for keyboard navigation

Machine Readability:

Structure content to be understandable by search engines and AI agents
Group related content semantically close in the DOM
Use Schema.org microdata where appropriate

Technical Details:

All code in a single HTML file
Use modern CSS (Grid, Flexbox, Custom Properties, clamp())
Add smooth transitions for all interactive elements
Include meta tags for SEO and social media
Make design fully responsive (mobile-first approach)

Final Result:
Create a fully functional, beautiful, and semantically correct HTML document that:

Looks visually stunning
Loads and renders quickly
Is accessible to all users
Is easily parsed by machines and AI
Maintains functionality even with styles disabled

DON'T put any emojis anywhere
Save it as a separate design.html file` },
            { number: "4", title: "Кластерные статьи", content: `Теперь, используя все твои знания о хуманизации, напиши максимально очеловеченный текст на английском языке для английской аудитории для первых двух кластерных статей. Сохрани их в отдельные .md файлы и именуй по принципу index1, index2, index3 и т.д. Не затягивай текст в код. Текста должно быть от 70%, списков до 30% всего визуального объёма каждой отдельной статьи. Жирного шрифта не более 20%.
Не добавляй оглавления и разделители между частями статей.
Целевой диапазон: 3000-4000 слов.
НЕ генерируй FAQ. КРИТИЧЕСКИ ВАЖНО: не используй в тексте никаких языков, кроме английского.

ЗАПРЕЩЕНО в тексте статьи:
- Эмодзи
- Выдуманные внешние ссылки и placeholder-ссылки (example.com и т.п.)
- Перекрёстные ссылки на другие статьи проекта
- Ссылки на несуществующие ресурсы

РАЗРЕШЕНО:
- Ссылки на реальные авторитетные источники (только если действительно необходимы)

После написания каждой статьи выполняй проверку на ошибки: орфографические, пунктуационные, фактические. Используй веб-поиск. Исправь при обнаружении.` },
            { number: "5", title: "Кластеры - код и изображения", content: `Обрабатывай только кластерные статьи indexN.md (НЕ трогай index.md и design.html).
Сейчас сделай только index1.md и index2.md.

Ты — опытный эксперт по HTML-вёрстке и генерации промтов для изображений.

═══════════════════════════════════════════════════════════════════
ЯЗЫК И КОДИРОВКА
═══════════════════════════════════════════════════════════════════
КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для английского:
Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию

═══════════════════════════════════════════════════════════════════
ЗАДАЧА
═══════════════════════════════════════════════════════════════════
Для каждого .md файла:
1. Конвертируй Markdown в HTML
2. Интегрируй 6 изображений
3. Создай промты для генерации изображений

Текст переноси СЛОВО В СЛОВО. Не сокращай, не перефразируй.

═══════════════════════════════════════════════════════════════════
HTML
═══════════════════════════════════════════════════════════════════
Создай чистый HTML без CSS, без стилей, без классов.
Структура: <!DOCTYPE html>, <html>, <head> с meta charset и viewport, <body>, <article>.
Вставь ровно 6 тегов <img>:
- Hero (первое): без loading="lazy"
- Остальные 2-6: с loading="lazy"
- Формат: только .webp
- Alt-теги: на языке статьи

Никаких эмодзи.

═══════════════════════════════════════════════════════════════════
ИЗОБРАЖЕНИЯ
═══════════════════════════════════════════════════════════════════

Общие требования:
- Ровно 6 изображений на страницу
- Реалистичные или гиперреалистичные
- Понятные с первого взгляда
- Логично соответствуют теме секции
- Без абстракции и футуризма
- Alt-теги и текст внутри изображений — на языке страницы
- Ничего не обрезано

Категорически запрещено:
- Абстрактные и футуристичные сцены
- Нереалистичные формы и пропорции
- Калькуляторы
- Календари
- Реальные деньги и банковские карты

Обязательные замены:
- Калькулятор → человек считает / документ / простой график без цифр
- Календарь → планирование / таймлайн / блокнот (не сетка)
- Деньги → символические знаки (€ / $)

Hero-изображение (№1):
- Один главный объект или простая сцена
- Сильное визуальное впечатление (свет, композиция)
- Без графиков, таблиц, KPI и интерфейсов
- Допустим короткий заголовок на языке страницы
- Ничего не обрезано

Остальные изображения (2–6):
- Допускаются простые визуализации, аккуратные графики и чистые интерфейсы

СПОРТ (для спортивных страниц):
- В промптах явно обозначь вид спорта на основе контекста статьи
- Указывай: тип поля/покрытия, корректный инвентарь, корректную экипировку

═══════════════════════════════════════════════════════════════════
ФОРМАТ ВЫВОДА
═══════════════════════════════════════════════════════════════════

Для каждой статьи создай 2 файла:

1. index[N].html — HTML с 6 изображениями
2. prompts[N].txt — для каждого изображения: промт, имя файла (.webp), размер (px), место в тексте

Именование: сохраняй исходные имена файлов. Не переименовывай по порядку обработки.

═══════════════════════════════════════════════════════════════════
ПЕРЕД СОХРАНЕНИЕМ
═══════════════════════════════════════════════════════════════════
Посчитай теги <img> в HTML. Если их не ровно 6 — исправь.`, instruction: {"type": "info", "text": "Прикрепить index1.md, index2.md, index3.md, index4.md, index5.md", "icon": "paperclip"} },
            { number: "6", title: "Pillar - код и изображения", content: `Ты — опытный UI-дизайнер и эксперт по HTML-вёрстке и генерации промтов для изображений.

═══════════════════════════════════════════════════════════════════
ВХОДНЫЕ ДАННЫЕ
═══════════════════════════════════════════════════════════════════
- index.md — текст статьи
- design.html — дизайн-шаблон

═══════════════════════════════════════════════════════════════════
ЯЗЫК И КОДИРОВКА
═══════════════════════════════════════════════════════════════════
КРИТИЧЕСКИ ВАЖНО - КОДИРОВКА UTF-8 для английского:
Используй только кодировку UTF-8
Копируй текст БУКВАЛЬНО, символ за символом
НЕ используй ASCII-транслитерацию

═══════════════════════════════════════════════════════════════════
ЗАДАЧА
═══════════════════════════════════════════════════════════════════
1. Возьми ВЕСЬ текст из index.md
2. Оберни в дизайн из design.html
3. Интегрируй 6 изображений
4. Создай CSS для изображений
5. Создай промты для генерации изображений

Текст переноси СЛОВО В СЛОВО. Не сокращай, не перефразируй.

═══════════════════════════════════════════════════════════════════
HTML
═══════════════════════════════════════════════════════════════════
Конвертируй Markdown в HTML.
Применяй дизайн из design.html.

Вставь ровно 6 тегов <img>:
- Hero (первое): без loading="lazy"
- Остальные 2-6: с loading="lazy"
- Формат: только .webp
- Alt-теги: на языке статьи

Никаких эмодзи.

Разбиение на артефакты:
Файл большой — разбивай на 3 артефакта, затем объедини в один index.html.

═══════════════════════════════════════════════════════════════════
CSS
═══════════════════════════════════════════════════════════════════
Создай images-styles.css:
- Адаптивность для desktop/mobile
- Hover-эффекты
- Мягкие анимации

═══════════════════════════════════════════════════════════════════
ИЗОБРАЖЕНИЯ
═══════════════════════════════════════════════════════════════════

Общие требования:
- Ровно 6 изображений на страницу
- Реалистичные или гиперреалистичные
- Понятные с первого взгляда
- Логично соответствуют теме секции
- Без абстракции и футуризма
- Alt-теги и текст внутри изображений — на языке страницы
- Ничего не обрезано

Категорически запрещено:
- Абстрактные и футуристичные сцены
- Нереалистичные формы и пропорции
- Калькуляторы
- Календари
- Реальные деньги и банковские карты

Обязательные замены:
- Калькулятор → человек считает / документ / простой график без цифр
- Календарь → планирование / таймлайн / блокнот (не сетка)
- Деньги → символические знаки (€ / $)

Hero-изображение (№1):
- Один главный объект или простая сцена
- Сильное визуальное впечатление (свет, композиция)
- Без графиков, таблиц, KPI и интерфейсов
- Допустим короткий заголовок на языке страницы
- Ничего не обрезано

Остальные изображения (2–6):
- Допускаются простые визуализации, аккуратные графики и чистые интерфейсы

СПОРТ (для спортивных страниц):
- В промптах явно обозначь вид спорта на основе контекста статьи
- Указывай: тип поля/покрытия, корректный инвентарь, корректную экипировку

═══════════════════════════════════════════════════════════════════
ФОРМАТ ВЫВОДА
═══════════════════════════════════════════════════════════════════

Создай 3 файла:

1. index.html — HTML с дизайном и 6 изображениями
2. images-styles.css — стили для изображений
3. prompts.txt — для каждого изображения: промт, имя файла (.webp), размер (px), место в тексте

═══════════════════════════════════════════════════════════════════
ПЕРЕД СОХРАНЕНИЕМ
═══════════════════════════════════════════════════════════════════
Посчитай теги <img> в HTML. Если их не ровно 6 — исправь.`, instruction: {"type": "info", "text": "Прикрепить index.md и design.html", "icon": "paperclip"} },
            { number: "7", title: "Технические страницы", content: `Войди в роль опытного SEO-копирайтера и редактора с глубоким знанием английского языка, маркетинга и поисковой оптимизации. 

Проанализируй сайт в index.html, затем указанные ниже страницы и напиши аналогичные для этого сайта на английском языке для англоязычной аудитории. Не нумеруй подразделы. Не используй эмодзи. Не вставляй placeholder ссылки или почтовые адреса, по типу "example.com" или "@example.com". Затягивай готовую страницу сразу в HTML. ГЕНЕРИРУЙ только чистый контент с простыми списками без классов, c основным текстом внутри тега article.
Генерируй мета тайтл/деск для страниц в начале. 
НЕ генерируй стилей.

ЗАПРЕЩЕНО:
- Любые placeholder-ссылки (example.com, yoursite.com, tudominio.com и т.п.)
- Выдуманные email-адреса (info@example.com, contact@company.com и т.п.)
- Выдуманные телефоны и адреса офисов
- Любые заглушки, которые подразумевают замену

РАЗРЕШЕНО:
- Ссылки на реальные официальные сайты (законодательство страны, регуляторы азартных игр и т.п.)
- Страницы без контактных данных — это нормально для данного типа сайтов

У тебя должно получиться четыре страницы.

ПЕРВАЯ СТРАНИЦА:

Privacy Policy
https://www.sportwettenvergleich.net/datenschutz/
https://sportwettenschweiz.pro/datenschutz/
https://sport-oesterreich.at/datenschutz/
https://sportwetten-helden.com/datenschutzerklarung/
https://sportwettenschweiz.com/datenschutzrichtlinie/
https://www.vanguardngr.com/casino/de/datenschutz/
https://sportwetten-online.com/datenschutzerklaerung
https://schweizerwettanbieter.com/datenschutzerklaerung/
https://www.wettenoesterreich.at/datenschutzerklaerung/
https://wettformat.com/at/datenschutzerklaerung
https://www.sportwettentest.net/datenschutz/
https://www.wettanbieter.de/datenschutz/
https://www.transfermarkt.de/sportwetten/datenschutzhinweis/
https://www.wettanbieter.org/datenschutz/
https://www.wettbuero.de/disclaimer/

---------------------------------------------------

ВТОРАЯ СТРАНИЦА:

About Us
https://www.sportwettenvergleich.net/ueber-uns/
https://www.sportwettenoesterreich.at/ueber-uns.html
https://sportwettenschweiz.pro/about/
https://sportwetten-helden.com/ueber-uns/
https://sportwettenschweiz.com/uber-uns/
https://sportwettenschweiz.ch/uber-uns/
https://www.vanguardngr.com/casino/de/uber-uns/
https://www.wettenoesterreich.at/ueber-uns/
https://www.wett-bonus.com/ueber-uns/
https://wettformat.com/at/ueber-uns
https://www.sportwettentest.net/about/
https://www.wettanbieter.de/autoren/
https://www.wettanbieter.org/ueber-uns/

---------------------------------------------------

ТРЕТЬЯ СТРАНИЦА:

Legal Information
https://www.sportwettenvergleich.net/impressum/
https://sportwettenschweiz.pro/impressum/
https://sport-oesterreich.at/impressum/
https://sportwetten-helden.com/impressum/
https://sportwetten-online.com/impressum
https://wettformat.com/at/impressum
https://www.sportwettentest.net/impressum/
https://www.wettanbieter.de/impressum/
https://www.transfermarkt.de/sportwetten/impressum/
https://www.wettbasis.com/impressum
https://www.wettbuero.de/impressum/

---------------------------------------------------

ЧЕТВЁРТАЯ СТРАНИЦА:

Cookie Policy
https://sportwettenschweiz.pro/cookie-richtlinien/
https://sportwetten-helden.com/eu-cookie-richtlinien/
https://wettformat.com/at/cookie-richtlinie
https://www.sportwettentest.net/cookie-richtlinie/
https://www.wettanbieter.de/cookie-policy/
https://www.transfermarkt.de/sportwetten/cookie-policy-eu/
https://www.wettbasis.com/cookie-richtlinie
https://www.sportwettenvergleich.net/cookie-policy/
https://sportwetten-magazin.com/cookie-policy/
https://www.sportwetten-community.de/cookie-richtlinie-eu` }
        ];
        
        const PROMPTS_DATA_ADAPTATION = [
            { number: "1", title: "Адаптация на английском (без перевода)", content: `Ты — профессиональный локализатор контента.
Задача: Адаптировать статью с австралийского сайта под Великобританию (Англию).

Входные данные: HTML-страница с оригинальной статьёй.

При этом в первую очередь (если речь идёт о платёжных системах и провайдерах игр) ты должен провести анализ - действуют ли эти системы и провайдеры в указанном на территории Великобритании. Если нет, ты должен сразу об этом сообщить (на русском языке) и не приступать к дальнейшим действиям. Если работают, переходи к следующим этапам этого промпта.

Любые миниатюры игр (картинки со ссылками и без) в тексте статей по провайдерам - ИГНОРИРОВАТЬ

Требования к культурной адаптации:

Заменить страну/регион оригинала на Великобританию (например, «Australian Online Casinos» → «English Online-Casinos», «Australian players» → «English players»)
Заменить название бренда «Ausslots» / «Auslots» на «Top Casino Europe» во всех случаях (заголовки, текст, призывы к действию)
НИ В КОЕМ СЛУЧАЕ не использовать термин «Pokies» в генерируемой статье, заменять его на «Slots»
Адаптировать юридические/регуляторные упоминания под целевой регион (например, упоминание местного законодательства)
В региональных сравнениях: заменить страну оригинала на Великобританию, при упоминании австралийских регионов - адаптировать их логично
Культурные события и примеры: заменять на НЕЙТРАЛЬНЫЕ или УНИВЕРСАЛЬНЫЕ (Рождество, Пасха, Новый год), а НЕ на специфические национальные праздники целевой страны, если это не уместно по контексту
Адаптировать форматы дат, валют (AUD → GBP, $ → £), единиц измерения
Актуальные годы: начиная с 2026 (и далее - если того требует дата будущего события (например, чемпионат мира в 2027 или любом другом году после 2026)

Требования к формату вывода:

Готовый HTML-файл с реальными HTML-тегами (НЕ псевдоразметка в квадратных скобках)
Название выходного файла: перевод названия оригинального файла на целевой язык с сохранением структуры и смысла, без добавления элементов, отсутствующих в оригинале
Структура тегов:
• Заголовок статьи → <h1>
• Подзаголовки → <h2> или <h3>
• Абзацы → <p>
• Списки → <ul> / <ol> с <li>
• Места для изображений → <div class="img-placeholder">[IMG: краткое описание]</div> (описание прописывается на целевом языке - на который переводится статья)
• Теги должны быть чистыми, без атрибутов (id, class, style и т.д.), кроме случаев, явно указанных выше (img-placeholder)
• Если в тексте оригинальной статьи используются референтные ссылки для отдельных слов/сочетаний по типу <a href="#">...</a>, эти теги следует удалять, чтобы в итоговой статье никаких внутренних ссылок на другие страницы не было
• НЕ добавлять: декоративные линии, цветные заголовки, цветные рамки, тени, градиенты или любые другие визуальные украшения
CSS-стили НЕ добавлять — использовать только стандартные браузерные стили
Игнорировать все мета-элементы, навигацию, виджеты, ссылки и другие технические веб-атрибуты исходника

Выходные данные: HTML-файл с переведённой и локализованной статьёй, готовый к просмотру в браузере.`, instruction: {"type": "info", "icon": "paperclip", "text": "К промту в Claude добавляется файл HTML"} },
            { number: "2", title: "Адаптация и перевод", content: `Ты — профессиональный переводчик и локализатор контента.
Задача: Перевести статью с английского на example язык с культурной адаптацией для example аудитории.

Входные данные: HTML-страница с оригинальной статьёй.

При этом в первую очередь (если речь идёт о платёжных системах и провайдерах игр) ты должен провести анализ - действуют ли эти системы и провайдеры в указанном ГЕО-регионе (ГЕО вычисляется на основе целевого языка (языка, на который будут осуществляться перевод и адаптация). В случае если в соответствующем ГЕО они не работают, ты должен сразу об этом сообщить (на русском языке) и не приступать к дальнейшим действиям. Если работают, переходи к следующим этапам этого промпта.

Любые миниатюры игр (картинки со ссылками и без) в тексте статей по провайдерам - ИГНОРИРОВАТЬ

Требования к переводу:

Сохранить смысл и тон оригинала
Использовать естественные для целевого языка конструкции (не калькировать с исходного)
НЕ сокращать исходную информацию и НЕ добавлять ничего от себя
Сохранить структуру оригинала в части всех заголовков/подзаголовков/списков

Требования к культурной адаптации:

Заменить страну/регион оригинала на страну целевой аудитории (например, «Australian Online Casinos» → «deutsche Online-Casinos», «Australian players» → «deutsche Spieler»)
Заменить название бренда «Ausslots» / «Auslots» на «Top Casino Europe» во всех случаях (заголовки, текст, призывы к действию)
НИ В КОЕМ СЛУЧАЕ не использовать термин «Pokies» в генерируемой статье, заменять его на «Slots»
Адаптировать юридические/регуляторные упоминания под целевой регион (например, упоминание местного законодательства)
В региональных сравнениях: заменить страну оригинала на страну целевой аудитории, остальные регионы оставить или адаптировать логично (например, «Europe» → «übriges Europa»)
Культурные события и примеры: заменять на НЕЙТРАЛЬНЫЕ или УНИВЕРСАЛЬНЫЕ (Рождество, Пасха, Новый год), а НЕ на специфические национальные праздники целевой страны, если это не уместно по контексту
Адаптировать форматы дат, валют (например, AUD → €), единиц измерения
Актуальные годы: начиная с 2026 (и далее - если того требует дата будущего события (например, чемпионат мира в 2027 или любом другом году после 2026)

Требования к формату вывода:

Готовый HTML-файл с реальными HTML-тегами (НЕ псевдоразметка в квадратных скобках)
Название выходного файла: перевод названия оригинального файла на целевой язык с сохранением структуры и смысла, без добавления элементов, отсутствующих в оригинале
Структура тегов:
• Заголовок статьи → <h1>
• Подзаголовки → <h2> или <h3>
• Абзацы → <p>
• Списки → <ul> / <ol> с <li>
• Места для изображений → <div class="img-placeholder">[IMG: краткое описание]</div> (описание прописывается на целевом языке - на который переводится статья)
• Теги должны быть чистыми, без атрибутов (id, class, style и т.д.), кроме случаев, явно указанных выше (img-placeholder)
• Если в тексте оригинальной статьи используются референтные ссылки для отдельных слов/сочетаний по типу <a href="#">...</a>, эти теги следует удалять, чтобы в итоговой статье никаких внутренних ссылок на другие страницы не было
• НЕ добавлять: декоративные линии, цветные заголовки, цветные рамки, тени, градиенты или любые другие визуальные украшения
CSS-стили НЕ добавлять — использовать только стандартные браузерные стили
Игнорировать все мета-элементы, навигацию, виджеты, ссылки и другие технические веб-атрибуты исходника

Выходные данные: HTML-файл с переведённой и локализованной статьёй, готовый к просмотру в браузере.`, instruction: {"type": "input", "icon": "edit", "text": "Смена целевых языка и аудитории", "fields": [{"label": "Введите целевой язык", "placeholder": "", "prefix": "Задача: Перевести статью с английского на ", "optional": false}, {"label": "Введите целевую аудиторию", "placeholder": "", "prefix": "с культурной адаптацией для ", "optional": false}]} },
            { number: "3", title: "Создание промптов под изображения", content: `СОЗДАНИЕ ФАЙЛА С ПРОМПТАМИ НА ОСНОВАНИИ И В СООТВЕТСТВИИ С ИСХОДНОЙ СТАТЬЁЙ
-------------------------------------------------------------------
Для каждого из представленных в html-файле изображений (анализировать ТОЛЬКО изображения, включенные непосредственно в текст основной статьи, игнорируя все мета-элементы, навигацию, виджеты, ссылки и другие технические веб-атрибуты исходника) создай детальное описание:

Формат:

ПРОМПТ:
Детальное описание для генерации изображения, максимально точно передающее (копирующее) содержание исходного изображения (но с поправкой на пункт "ОБРАТИТЬ ОТДЕЛЬНОЕ ВНИМАНИЕ" из текущего промпта), 
Включи: стиль, композицию, объекты, освещение, цветовую палитру, настроение.
Если в исходном изображении содержатся надписи на английском, укажи их в сгенерированном промпте на следующем языке: example
Любые миниатюры игр (картинки со ссылками и без) в тексте статей по провайдерам - ИГНОРИРОВАТЬ

Имя файла: [seo-optimized-name].png
Размер: [ширина]x[высота] px

═══════════════════════════════════════════════════════════════════
ПРАВИЛА ДЛЯ ПРОМПТОВ ИЗОБРАЖЕНИЙ
═══════════════════════════════════════════════════════════════════

ОБЩИЕ ТРЕБОВАНИЯ:
-------------------------------------------------------------------

Название изображения в готовом промпте должны быть представлены на следующем языке: example
Остальная часть промпта: на английском

ДА:
- Реалистичный или гиперреалистичный стиль
- Понятно с первого взгляда — без абстракции
- Логическая связь с контекстом секции статьи
- Все надписи внутри изображения — на языке статьи
- Чистая композиция, современный дизайн

НЕТ — КАТЕГОРИЧЕСКИ ЗАПРЕЩЕНО:
- Абстрактные изображения
- Футуристичные сцены без логики
- Искаженные пропорции
- Калькуляторы (любые: цифровые, бумажные, интерфейсные)
- Календари (любые: настенные, мобильные, UI-календари)
- Реальные деньги и банковские карты
- Перегруженные диаграммы с мелкими элементами
- Сложные интерфейсы
- Визуальный шум и хаос

Все изображения могут включать:
- Упрощенные графики (чистые, понятные)
- Минималистичные интерфейсы
- Прикладные визуализации по теме секции
- Умеренное количество надписей (крупно, читаемо)
- Людей в контексте темы статьи

ЗАМЕНЫ ДЛЯ ЗАПРЕЩЕННЫХ ЭЛЕМЕНТОВ:
-------------------------------------------------------------------
Вместо калькулятора:
- человек, делающий расчеты за столом
- рука с ручкой над документом
- простой понятный график
- человек за ноутбуком

Вместо календаря:
- человек, планирующий задачи в блокноте
- часы или таймлайн
- дорожная карта / план
- список дел (без календарной сетки)

Вместо денег:
- символическая иконка валюты
- графический элемент роста
- человек с документом/контрактом
- нейтральный знак валюты без контекста

Вместо любых других запрещенных элементов:
- Действуй по аналогии — заменяй на нейтральную альтернативу
- Альтернатива должна передавать тот же смысл
- Используй реалистичные объекты, людей, простые визуализации
- Ни в коем случае не допускай прямого изображения запрещенного элемента

-------------------------------------------------------------------

В случае если на изображении в исходной статье содержится логотип реально существующей компании, в описании промпта под это изображение необходимо указать (на русском языке), что "Отдельная генерация изображения не требуется. Используйте логотип [название реально существующей компании, чей логотип подразумевается].

ОБРАТИТЬ ОТДЕЛЬНОЕ ВНИМАНИЕ: все атрибуты внутри изображения, связанные с Австралией (если таковые имеются) в промпте необходимо заменять на нейтральные (европейские).
Если оригинальная страница содержит раздел под названием "Popular Payment Methods in Australian Online Casinos", полностью игнорировать приведённые в нём пиктограммы с кредитными картами и банковскими переводами (4 штуки).

═══════════════════════════════════════════════════════════════════
ФОРМАТ ВЫВОДА
═══════════════════════════════════════════════════════════════════

ФАЙЛ: prompts.txt

Включает в себя:

- Номер и тип изображения
- Место размещения в статье (указывается лишь числовая позиция изображения в исходнике - по типу Img1, Img2, Img3 и так далее - в зависимости от количества изображений), никаких дополнительных комментариев по поводу раздела статьи не требуется
- Детальный промпт для последующей генерации изображения
- Имя файла
- Размер в пикселях`, instruction: {"type": "input", "icon": "edit", "text": "Смена целевого языка (в двух позициях)", "fields": [{"label": "Целевой язык (позиция 1)", "placeholder": "", "prefix": "Если в исходном изображении содержатся надписи на английском, укажи их в сгенерированном промпте на следующем языке: ", "optional": false}, {"label": "Целевой язык (позиция 2)", "placeholder": "", "prefix": "Название изображения в готовом промпте должны быть представлены на следующем языке: ", "optional": false}]} }
        ];
        
        // Конвертируем старые массивы в структуру вкладок
        function convertToTabStructure(id, name, order, blocks, chatBreakAfter) {
            const items = [];
            // Поддержка нескольких chatBreak через запятую: '1,2' или '3'
            const chatBreakNumbers = chatBreakAfter ? chatBreakAfter.split(',') : [];
            
            blocks.forEach(b => {
                // Добавляем блок
                items.push({
                    type: 'block',
                    id: generateItemId(),
                    title: b.title,
                    content: b.content || '',
                    instruction: b.instruction ? b.instruction : (b.note ? { type: "info", text: b.note } : null)
                });
                
                // Добавляем chatBreak после указанных блоков или если у блока есть chatBreakAfter
                if (chatBreakNumbers.includes(b.number) || b.chatBreakAfter) {
                    items.push({
                        type: 'chatBreak',
                        id: generateItemId()
                    });
                }
            });
            
            return {
                id,
                name,
                order,
                items
            };
        }
        
        // Инициализация дефолтных вкладок при первом запуске
        function initializeDefaultTabs() {
            if (localStorage.getItem(TABS_STORAGE_KEY)) {
                // Данные уже есть - проверяем и мигрируем инструкции если нужно
                migrateInstructions();
                return;
            }
            
            // Инструкции уже встроены в PROMPTS_DATA
            // Добавляем инструкции для PROMPTS_DATA_TASK4
            PROMPTS_DATA_TASK4[0].instruction = { type: "info", icon: "paperclip", text: "Прикрепить html-файл сайта" };
            PROMPTS_DATA_TASK4[2].instruction = { type: "info", icon: "paperclip", text: "Прикрепить файлы index1-30.md" };
            
            // Добавляем инструкции для PROMPTS_DATA_ADAPTATION
            PROMPTS_DATA_ADAPTATION[0].instruction = { type: "info", icon: "paperclip", text: "К промту в Claude добавляется файл HTML" };
            PROMPTS_DATA_ADAPTATION[1].instruction = { type: "input", icon: "edit", text: "Смена целевых языка и аудитории", fields: [{ label: "Введите целевой язык", placeholder: "", prefix: "Задача: Перевести статью с английского на ", optional: false }, { label: "Введите целевую аудиторию", placeholder: "", prefix: "с культурной адаптацией для ", optional: false }] };
            PROMPTS_DATA_ADAPTATION[2].instruction = { type: "input", icon: "edit", text: "Смена целевого языка (в двух позициях)", fields: [{ label: "Целевой язык (позиция 1)", placeholder: "", prefix: "Если в исходном изображении содержатся надписи на английском, укажи их в сгенерированном промпте на следующем языке: ", optional: false }, { label: "Целевой язык (позиция 2)", placeholder: "", prefix: "Название изображения в готовом промпте должны быть представлены на следующем языке: ", optional: false }] };
            
            const defaultTabs = {
                'default': convertToTabStructure('default', 'PILLAR-PICS', 1, PROMPTS_DATA, '5'),
                'task2': convertToTabStructure('task2', 'PILLAR-TASK2', 2, PROMPTS_DATA_TASK2, '5'),
                'task4': convertToTabStructure('task4', 'CLUSTERS-PICS', 3, PROMPTS_DATA_TASK4, '2'),
                'adaptation': convertToTabStructure('adaptation', 'ADAPTATION', 4, PROMPTS_DATA_ADAPTATION, '1,2')
            };
            
            saveAllTabs(defaultTabs);
            console.log('Default tabs initialized');
        }
        
        // Миграция инструкций для существующих данных
        function migrateInstructions() {
            const tabs = getAllTabs();
            let needsSave = false;
            
            // Дефолтные инструкции для PILLAR-PICS вкладки
            const defaultInstructions = {
                '1': { type: "input", icon: "edit", text: "Заменить ключевое слово и контекст", fields: [{ label: "Ключевое слово", placeholder: "", prefix: "по ключевому слову", optional: false }, { label: "Контекст", placeholder: "", prefix: "в контексте", optional: true }] },
                '5': { type: "info", icon: "paperclip", text: "Прикрепить index1.md, index2.md, index3.md, index4.md, index5.md" },
                '6': { type: "info", icon: "paperclip", text: "Прикрепить index.md и design.html" }
            };
            
            // Дефолтные инструкции для CLUSTERS-PICS вкладки
            const task4Instructions = {
                '1': { type: "info", icon: "paperclip", text: "Прикрепить html-файл сайта" },
                '3': { type: "info", icon: "paperclip", text: "Прикрепить файлы index1-30.md" }
            };
            
            // Дефолтные инструкции для ADAPTATION вкладки
            const adaptationInstructions = {
                '1': { type: "info", icon: "paperclip", text: "К промту в Claude добавляется файл HTML" },
                '2': { type: "input", icon: "edit", text: "Смена целевых языка и аудитории", fields: [{ label: "Введите целевой язык", placeholder: "", prefix: "Задача: Перевести статью с английского на ", optional: false }, { label: "Введите целевую аудиторию", placeholder: "", prefix: "с культурной адаптацией для ", optional: false }] },
                '3': { type: "input", icon: "edit", text: "Смена целевого языка (в двух позициях)", fields: [{ label: "Целевой язык (позиция 1)", placeholder: "", prefix: "Если в исходном изображении содержатся надписи на английском, укажи их в сгенерированном промпте на следующем языке: ", optional: false }, { label: "Целевой язык (позиция 2)", placeholder: "", prefix: "Название изображения в готовом промпте должны быть представлены на следующем языке: ", optional: false }] }
            };
            
            if (tabs.default && tabs.default.blocks) {
                tabs.default.blocks.forEach(block => {
                    if (!block.instruction && defaultInstructions[block.number]) {
                        block.instruction = defaultInstructions[block.number];
                        needsSave = true;
                    }
                });
            }
            
            if (tabs.task4 && tabs.task4.blocks) {
                tabs.task4.blocks.forEach(block => {
                    if (!block.instruction && task4Instructions[block.number]) {
                        block.instruction = task4Instructions[block.number];
                        needsSave = true;
                    }
                });
            }
            
            if (tabs.adaptation && tabs.adaptation.blocks) {
                tabs.adaptation.blocks.forEach(block => {
                    if (!block.instruction && adaptationInstructions[block.number]) {
                        block.instruction = adaptationInstructions[block.number];
                        needsSave = true;
                    }
                });
            }
            
            if (needsSave) {
                saveAllTabs(tabs);
                console.log('Instructions migrated');
            }
            
            // Мигрируем все вкладки к новому формату items
            let itemsMigrated = false;
            Object.keys(tabs).forEach(tabId => {
                const tab = tabs[tabId];
                if (tab.blocks && !tab.items) {
                    migrateTabToItems(tab);
                    itemsMigrated = true;
                }
            });
            
            if (itemsMigrated) {
                saveAllTabs(tabs);
                console.log('Tabs migrated to items format');
            }
        }
        
        // Утилита для устранения дребезга (debounce)
        const debounce = (func, delay) => {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };
        };


        // --- ОПЕРАЦИИ С LOCAL STORAGE ---

        /**
         * Возвращает ключ localStorage для текущей вкладки
         */
        function getCurrentStorageKey() {
            // Обратная совместимость для встроенных вкладок
            if (currentTab === 'default') return LOCAL_STORAGE_KEY;
            if (currentTab === 'task4') return LOCAL_STORAGE_KEY_TASK4;
            // Для кастомных вкладок — уникальный ключ
            return `ai-prompts-manager-data-${currentTab}`;
        }

        /**
         * Сохраняет содержимое промпта в локальное хранилище.
         * @param {string} number - Номер секции промпта (от 1 до 10).
         * @param {string} content - Содержимое для сохранения.
         */
        function saveToLocalStorage(key, content) {
            try {
                const storageKey = getCurrentStorageKey();
                const storedData = JSON.parse(localStorage.getItem(storageKey) || '{}');
                storedData[key] = content;
                localStorage.setItem(storageKey, JSON.stringify(storedData));
                // Сохраняем версию данных
                localStorage.setItem(DATA_VERSION_KEY, CURRENT_DATA_VERSION.toString());
            } catch (e) {
                console.error("Ошибка при сохранении в LocalStorage:", e);
            }
        }

        /**
         * Загружает промпты из локального хранилища.
         * @returns {Object} Сохраненный объект промптов или пустой объект.
         */
        function loadFromLocalStorage() {
            try {
                const storageKey = getCurrentStorageKey();
                // Проверяем версию данных
                const savedVersion = parseInt(localStorage.getItem(DATA_VERSION_KEY) || '0');
                if (savedVersion < CURRENT_DATA_VERSION) {
                    // Версия устарела - очищаем старые данные
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    localStorage.removeItem(LOCAL_STORAGE_KEY_TASK4);
                    localStorage.removeItem(LANGUAGE_STORAGE_KEY);
                    localStorage.setItem(DATA_VERSION_KEY, CURRENT_DATA_VERSION.toString());
                    return {};
                }
                return JSON.parse(localStorage.getItem(storageKey) || '{}');
            } catch (e) {
                console.error("Ошибка при загрузке из LocalStorage:", e);
                return {};
            }
        }

        /**
         * Проверяет версию приложения и сбрасывает данные при обновлении
         */
        async function checkAppVersionAndReset() {
            try {
                let currentAppVersion = '0.0.0';
                
                // Получаем версию из Tauri
                if (window.__TAURI__) {
                    try {
                        // Tauri 2 API
                        if (window.__TAURI__.core && window.__TAURI__.core.invoke) {
                            currentAppVersion = await window.__TAURI__.core.invoke('plugin:app|version');
                        } else if (window.__TAURI__.app && window.__TAURI__.app.getVersion) {
                            currentAppVersion = await window.__TAURI__.app.getVersion();
                        }
                    } catch (e) {
                        console.log('Could not get app version:', e);
                    }
                }
                
                const savedAppVersion = localStorage.getItem(APP_VERSION_KEY) || '0.0.0';
                
                // Сброс если версия изменилась (любой компонент: мажор, минор или патч)
                const needsReset = currentAppVersion !== savedAppVersion;
                
                if (needsReset && savedAppVersion !== '0.0.0') {
                    console.log(`App updated: ${savedAppVersion} → ${currentAppVersion}, resetting data...`);
                    // Сбрасываем только данные вкладок (контент)
                    localStorage.removeItem(TABS_STORAGE_KEY);
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    localStorage.removeItem(LOCAL_STORAGE_KEY_TASK4);
                    // НЕ трогаем: SETTINGS_STORAGE_KEY (тема, автообновление), язык
                }
                
                // Сохраняем текущую версию
                if (currentAppVersion !== '0.0.0') {
                    localStorage.setItem(APP_VERSION_KEY, currentAppVersion);
                }
                
            } catch (e) {
                console.error("Ошибка при проверке версии:", e);
            }
        }


        // --- ОСНОВНАЯ ЛОГИКА СОХРАНЕНИЯ И ЗАГРУЗКИ ---

        /**
         * Сохраняет содержимое промпта, используя активный механизм (только LocalStorage).
         * @param {string} key - ID блока или номер секции (для обратной совместимости).
         * @param {string} content - Содержимое для сохранения.
         */
        const savePrompt = debounce((key, content) => {
            saveToLocalStorage(key, content);
        }, 800); 

        /**
         * Инициализирует сохранение (только LocalStorage).
         */
        async function initializePersistence() {
            await checkAppVersionAndReset(); // Проверка версии и сброс при обновлении
            setupModalListeners(); // Настройка слушателей модального окна
        }

        /**
         * Создает кликабельную кнопку-разделитель.
         * @param {string} text - Текст на кнопке.
         * @param {boolean} isTop - Если true, уменьшает верхний отступ.
         * @returns {HTMLDivElement} Контейнер кнопки.
         */
        function createChatButton(text, isTop = false) {
            const separatorContainer = document.createElement('div');
            // Установка отступов
            separatorContainer.className = `chat-button-wrapper flex justify-center my-6 ${isTop ? 'mt-0' : ''}`; 
            
            const button = document.createElement('button');
            // Применяем новый цвет: bg-claude-accent, text-white, ring-claude-accent
            button.className = 'chat-button h-8 bg-claude-accent rounded-lg shadow-md w-fit flex items-center justify-center px-4 focus:outline-none focus:ring-2 ring-claude-accent focus:ring-opacity-50';
            button.innerHTML = `<span class="text-white text-base font-semibold whitespace-nowrap">${text}</span>`;
            
            // Обработчик нажатия: открыть новый чат Claude в браузере по умолчанию
            button.onclick = async () => {
                try {
                    // Используем Tauri opener plugin
                    if (window.__TAURI__?.opener) {
                        await window.__TAURI__.opener.openUrl(CLAUDE_NEW_CHAT_URL);
                    } else {
                        // Fallback для разработки в браузере
                        window.open(CLAUDE_NEW_CHAT_URL, '_blank');
                    }
                } catch (e) {
                    console.error('Failed to open URL:', e);
                    // Пробуем fallback
                    const fallbackWindow = window.open(CLAUDE_NEW_CHAT_URL, '_blank');
                    if (!fallbackWindow) {
                        // Если и fallback не сработал — показываем URL пользователю
                        alert(`Не удалось открыть браузер.\nСкопируйте ссылку вручную:\n${CLAUDE_NEW_CHAT_URL}`);
                    }
                }
                button.blur(); 
            };

            separatorContainer.appendChild(button);
            return separatorContainer;
        }
        
        // Создаёт кнопку "Новый чат" с возможностью удаления и перетаскивания (для режима редактирования)
        function createEditableChatBreak(itemId) {
            const separatorContainer = document.createElement('div');
            separatorContainer.className = 'chat-break-item sortable-item flex items-center gap-3 my-4 py-2 rounded-2xl';
            separatorContainer.dataset.itemId = itemId;
            separatorContainer.dataset.itemType = 'chatBreak';
            
            // Drag handle (как у блоков)
            const dragHandle = document.createElement('div');
            dragHandle.className = 'drag-handle text-gray-300';
            dragHandle.title = 'Перетащить';
            dragHandle.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 8h16M4 16h16" />
                </svg>
            `;
            
            const button = document.createElement('button');
            button.className = 'chat-button h-8 bg-claude-accent rounded-lg shadow-md w-fit flex items-center justify-center px-4 focus:outline-none focus:ring-2 ring-claude-accent focus:ring-opacity-50';
            button.innerHTML = `<span class="text-white text-base font-semibold whitespace-nowrap">Новый чат</span>`;
            button.onclick = async () => {
                try {
                    if (window.__TAURI__?.opener) {
                        await window.__TAURI__.opener.openUrl(CLAUDE_NEW_CHAT_URL);
                    } else {
                        window.open(CLAUDE_NEW_CHAT_URL, '_blank');
                    }
                } catch (e) {
                    window.open(CLAUDE_NEW_CHAT_URL, '_blank');
                }
                button.blur();
            };
            
            // Кнопка удаления
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-chat-break text-red-400 hover:text-red-600 p-1 rounded transition-colors';
            deleteBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            `;
            deleteBtn.title = 'Удалить разделитель';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                removeItemFromTab(currentTab, itemId);
                loadPrompts();
            };
            
            separatorContainer.appendChild(dragHandle);
            separatorContainer.appendChild(button);
            separatorContainer.appendChild(deleteBtn);
            return separatorContainer;
        }
        
        /**
         * Создает кнопку добавления нового блока
         */
        function createAddBlockButton() {
            const wrapper = document.createElement('div');
            wrapper.className = 'add-block-wrapper flex items-center justify-center my-6 relative';
            
            const button = document.createElement('button');
            button.className = 'add-block-btn w-12 h-12 bg-claude-accent rounded-full flex items-center justify-center transition-all focus:outline-none focus:ring-2 ring-claude-accent focus:ring-opacity-50';
            button.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                </svg>
            `;
            button.title = 'Добавить элемент';
            
            // Контекстное меню
            const menu = document.createElement('div');
            menu.className = 'add-menu hidden absolute bottom-full left-1/2 -translate-x-1/2 mb-2 bg-white rounded-lg shadow-lg border border-gray-200 overflow-hidden z-50';
            menu.innerHTML = `
                <button class="add-menu-item flex items-center gap-2 px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left whitespace-nowrap" data-action="block">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-claude-accent" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    Добавить блок
                </button>
                <button class="add-menu-item flex items-center gap-2 px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left whitespace-nowrap" data-action="chat">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-claude-accent" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                    </svg>
                    Новый чат
                </button>
            `;
            
            // Показываем/скрываем меню
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                menu.classList.toggle('hidden');
            });
            
            // Обработчики пунктов меню
            menu.querySelectorAll('.add-menu-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    menu.classList.add('hidden');
                    
                    if (action === 'block') {
                        addBlockToTab(currentTab);
                        loadPrompts();
                    } else if (action === 'chat') {
                        addChatBreakToTab(currentTab);
                        loadPrompts();
                    }
                });
            });
            
            // Закрываем при клике вне
            document.addEventListener('click', () => {
                menu.classList.add('hidden');
            });
            
            wrapper.appendChild(button);
            wrapper.appendChild(menu);
            return wrapper;
        }
        
        /**
         * Возвращает массив промптов для текущей вкладки
         */
        function getCurrentPromptsData() {
            return getTabBlocks(currentTab);
        }

        /**
         * Загружает промпты, рендерит UI и применяет сохраненные данные.
         */
        function loadPrompts() {
            const appElement = document.getElementById('app');
            const loadingOverlay = document.getElementById('loading-overlay');
            const sections = getCurrentPromptsData();
            const initialPrompts = loadFromLocalStorage();
            
            // Сбрасываем режим reorder
            isReorderMode = false;
            const reorderBtn = document.getElementById('reorder-blocks-btn');
            const reorderBtnText = document.getElementById('reorder-btn-text');
            if (reorderBtn && reorderBtnText) {
                reorderBtn.classList.add('text-gray-600', 'bg-white', 'border-gray-200');
                reorderBtn.classList.remove('text-white', 'bg-claude-accent', 'border-claude-accent');
                reorderBtnText.textContent = 'Порядок';
            }
            appElement.classList.remove('drag-mode');

            // Очищаем контейнер перед рендерингом
            appElement.innerHTML = '';

            // 1. Добавление верхнего разделителя-кнопки
            appElement.appendChild(createChatButton("Открыть Claude AI", true));

            // 2. Создаём контейнер для карточек (для SortableJS)
            const cardsContainer = document.createElement('div');
            cardsContainer.id = 'cards-container';
            cardsContainer.className = 'flex flex-col gap-4 pb-4';
            appElement.appendChild(cardsContainer);

            // 3. Рендеринг структуры UI на основе items
            const items = getTabItems(currentTab);
            let blockNumber = 1;
            
            items.forEach(item => {
                if (item.type === 'block') {
                    // Создаём объект section с номером
                    const section = {
                        ...item,
                        number: String(blockNumber++)
                    };
                    const card = createPromptCard(section);
                    cardsContainer.appendChild(card);
                } else if (item.type === 'chatBreak') {
                    if (isEditMode) {
                        // В режиме редактирования - с кнопкой удаления
                        cardsContainer.appendChild(createEditableChatBreak(item.id));
                    } else {
                        cardsContainer.appendChild(createChatButton("Новый чат"));
                    }
                }
            });
            
            // 3.5. Кнопка добавления блока (в режиме редактирования)
            if (isEditMode) {
                appElement.appendChild(createAddBlockButton());
            }
            
            // Обновляем кнопку редактирования
            updateEditTabButton();

            // 3. Применение сохраненного контента и немедленная корректировка высоты
            document.querySelectorAll('.textarea-content').forEach(textarea => {
                const number = textarea.dataset.number;
                const itemId = textarea.dataset.itemId;
                // Сначала пробуем загрузить по ID, потом по номеру (для обратной совместимости)
                const savedContent = initialPrompts[itemId] !== undefined ? initialPrompts[itemId] : initialPrompts[number];
                
                if (savedContent !== undefined) {
                    textarea.value = savedContent;
                } else if (currentLanguage !== 'en') {
                    // Если нет сохранённых данных и язык не английский - применяем текущий язык к шаблону
                    textarea.value = replaceLanguage(textarea.value, 'en', currentLanguage);
                }
                
                // Присоединение слушателя для динамического изменения размера и сохранения
                textarea.addEventListener('input', () => {
                    autoResizeTextarea(textarea);
                    savePrompt(itemId, textarea.value); // Сохраняем по ID блока
                });
                
                // Сохраняем состояние в undo стек при потере фокуса
                textarea.addEventListener('blur', () => {
                    saveToUndoStack();
                });
            });

            // 4. Скрыть оверлей загрузки и показать контент
            loadingOverlay.classList.add('hidden');
            appElement.classList.remove('hidden');

            // 5. ФИНАЛЬНАЯ БЕЗОПАСНАЯ КОРРЕКТИРОВКА ВЫСОТЫ ПОСЛЕ ОТРЕНДЕРИВАНИЯ
            window.requestAnimationFrame(() => {
                 document.querySelectorAll('.textarea-content').forEach(textarea => {
                    autoResizeTextarea(textarea);
                });
            });
            
            // 6. Инициализация SortableJS для перетаскивания блоков
            if (isEditMode) {
                initSortable();
            } else {
                destroySortable();
            }
        }
        
        // --- UI УТИЛИТЫ И РЕНДЕРИНГ ---

        /**
         * Инициализирует кастомный скроллбар для элемента
         * @param {HTMLElement} scrollable - элемент со скроллом
         * @param {HTMLElement} scrollbar - элемент скроллбара
         */
        // Глобальные переменные для скроллбаров
        let activeScrollbarData = null;

        function initCustomScrollbar(scrollable, scrollbar) {
            const thumb = scrollbar.querySelector('.custom-scrollbar-thumb') || scrollbar.querySelector('.main-scrollbar-thumb');
            
            function updateThumb() {
                const scrollHeight = scrollable.scrollHeight;
                const clientHeight = scrollable.clientHeight;
                const trackHeight = scrollbar.clientHeight;
                
                if (scrollHeight <= clientHeight) {
                    scrollbar.style.opacity = '0';
                    scrollbar.style.pointerEvents = 'none';
                    return;
                } else {
                    scrollbar.style.opacity = '1';
                    scrollbar.style.pointerEvents = 'auto';
                }
                
                const thumbHeight = Math.max(30, (clientHeight / scrollHeight) * trackHeight);
                const maxScroll = scrollHeight - clientHeight;
                const scrollPercent = scrollable.scrollTop / maxScroll;
                const thumbTop = scrollPercent * (trackHeight - thumbHeight);
                
                thumb.style.height = thumbHeight + 'px';
                thumb.style.top = thumbTop + 'px';
            }
            
            scrollable.addEventListener('scroll', updateThumb);
            
            const resizeObserver = new ResizeObserver(updateThumb);
            resizeObserver.observe(scrollable);
            
            thumb.addEventListener('mouseenter', () => {
                scrollbar.classList.add('active');
            });
            thumb.addEventListener('mouseleave', () => {
                if (!activeScrollbarData || !activeScrollbarData.isDragging || activeScrollbarData.scrollbar !== scrollbar) {
                    scrollbar.classList.remove('active');
                }
            });
            
            thumb.addEventListener('mousedown', (e) => {
                activeScrollbarData = {
                    isDragging: true,
                    scrollable,
                    scrollbar,
                    thumb,
                    startY: e.clientY,
                    startScrollTop: scrollable.scrollTop
                };
                thumb.classList.add('dragging');
                scrollbar.classList.add('active');
                e.preventDefault();
            });
            
            scrollbar.addEventListener('click', (e) => {
                if (e.target === thumb) return;
                
                const rect = scrollbar.getBoundingClientRect();
                const clickY = e.clientY - rect.top;
                const trackHeight = scrollbar.clientHeight;
                const scrollHeight = scrollable.scrollHeight;
                const clientHeight = scrollable.clientHeight;
                const scrollPercent = clickY / trackHeight;
                
                scrollable.scrollTop = scrollPercent * (scrollHeight - clientHeight);
            });
            
            setTimeout(updateThumb, 100);
        }

        /**
         * Динамически регулирует высоту текстового поля.
         * @param {HTMLTextAreaElement} element 
         */
        function autoResizeTextarea(element) {
            element.style.height = 'auto'; // Сброс высоты для корректного расчета scrollHeight
            
            const maxHeight = 350; 
            const minHeight = 175; 
            
            let naturalHeight = element.scrollHeight; 
            
            if (naturalHeight > maxHeight) {
                // Если контент длиннее максимальной высоты, принудительно устанавливаем maxHeight.
                element.style.height = `${maxHeight}px`;
            } else {
                // Иначе устанавливаем высоту по содержимому, соблюдая minHeight.
                element.style.height = `${Math.max(naturalHeight, minHeight)}px`;
            }
        }


        /**
         * Парсит сырой строковый контент в секции промптов.
         * @param {string} text - Исходный текст шаблона.
         * @returns {Array<Object>} Массив секций промптов.
         */
        // parsePrompts removed - using static PROMPTS_DATA

        // --- DRAG & DROP ДЛЯ БЛОКОВ (Reorder Mode) ---
        let dragState = {
            isDragging: false,
            draggedCard: null,
            placeholder: null,
            startY: 0,
            offsetY: 0
        };
        
        let isReorderMode = false;
        
        function toggleReorderMode() {
            if (isReorderMode) {
                exitReorderMode();
            } else {
                enterReorderMode();
            }
        }
        
        function enterReorderMode() {
            isReorderMode = true;
            const btn = document.getElementById('reorder-blocks-btn');
            const btnText = document.getElementById('reorder-btn-text');
            
            // Меняем вид кнопки
            btn.classList.remove('text-gray-600', 'bg-white', 'border-gray-200');
            btn.classList.add('text-white', 'bg-claude-accent', 'border-claude-accent');
            btnText.textContent = 'Применить';
            
            const container = document.getElementById('cards-container');
            const allItems = container.querySelectorAll('.sortable-item');
            
            // Сворачиваем все элементы с анимацией
            allItems.forEach(item => {
                const h = item.getBoundingClientRect().height;
                item.style.height = h + 'px';
                item.style.overflow = 'hidden';
                item.style.transition = 'height 0.15s ease-out';
            });
            
            document.getElementById('app').classList.add('drag-mode');
            
            requestAnimationFrame(() => {
                allItems.forEach(item => {
                    // Блоки сворачиваем до 70px, chatBreak до 50px
                    const targetHeight = item.dataset.itemType === 'chatBreak' ? '50px' : '70px';
                    item.style.height = targetHeight;
                });
            });
            
            // Инициализируем drag после сворачивания
            setTimeout(() => {
                initDragHandlers();
            }, 150);
        }
        
        function exitReorderMode() {
            isReorderMode = false;
            const btn = document.getElementById('reorder-blocks-btn');
            const btnText = document.getElementById('reorder-btn-text');
            
            // Возвращаем вид кнопки
            btn.classList.add('text-gray-600', 'bg-white', 'border-gray-200');
            btn.classList.remove('text-white', 'bg-claude-accent', 'border-claude-accent');
            btnText.textContent = 'Порядок';
            
            const container = document.getElementById('cards-container');
            
            // Сохраняем новый порядок
            saveBlocksOrder();
            
            // Сбрасываем transform у всех элементов
            container.querySelectorAll('.sortable-item').forEach(item => {
                item.style.transform = '';
            });
            
            // Убираем drag-mode чтобы контент стал видимым
            document.getElementById('app').classList.remove('drag-mode');
            
            // Анимируем разворачивание только для prompt-card
            const allCards = container.querySelectorAll('.prompt-card');
            const targetHeights = [];
            
            allCards.forEach(c => {
                c.style.transition = 'none';
                c.style.height = 'auto';
                targetHeights.push(c.getBoundingClientRect().height);
                c.style.height = '70px';
            });
            
            // Сбрасываем стили у chatBreak
            container.querySelectorAll('.chat-break-item').forEach(item => {
                item.style.height = '';
                item.style.overflow = '';
                item.style.transition = '';
            });
            
            requestAnimationFrame(() => {
                allCards.forEach((c, i) => {
                    c.style.transition = 'height 0.15s ease-out';
                });
                
                requestAnimationFrame(() => {
                    allCards.forEach((c, i) => {
                        c.style.height = targetHeights[i] + 'px';
                    });
                    
                    setTimeout(() => {
                        allCards.forEach(c => {
                            c.style.height = '';
                            c.style.overflow = '';
                            c.style.transition = '';
                        });
                        
                        // Перезагружаем для обновления всех данных
                        loadPrompts();
                    }, 150);
                });
            });
        }
        
        function initDragHandlers() {
            const container = document.getElementById('cards-container');
            if (!container) return;
            
            container.querySelectorAll('.drag-handle').forEach(handle => {
                handle.removeEventListener('mousedown', startDrag);
                handle.addEventListener('mousedown', startDrag);
            });
        }
        
        function initSortable() {
            // Теперь ничего не делаем при загрузке - drag включается по кнопке
        }
        
        function destroySortable() {
            // Ничего не нужно уничтожать
        }
        
        function startDrag(e) {
            if (!isReorderMode) return;
            
            e.preventDefault();
            const item = e.target.closest('.sortable-item');
            if (!item) return;
            
            dragState.isDragging = true;
            dragState.draggedCard = item;
            
            const rect = item.getBoundingClientRect();
            dragState.offsetY = e.clientY - rect.top;
            
            // Создаём placeholder с высотой как у элемента
            dragState.placeholder = document.createElement('div');
            dragState.placeholder.className = 'drag-placeholder';
            const placeholderHeight = item.dataset.itemType === 'chatBreak' ? '50px' : '70px';
            dragState.placeholder.style.height = placeholderHeight;
            
            // Вставляем placeholder
            item.parentNode.insertBefore(dragState.placeholder, item);
            
            // Делаем элемент fixed
            item.style.position = 'fixed';
            item.style.width = rect.width + 'px';
            item.style.left = rect.left + 'px';
            item.style.top = rect.top + 'px';
            item.style.zIndex = '9999';
            item.style.pointerEvents = 'none';
            item.classList.add('dragging');
            
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', endDrag);
        }
        
        function onDrag(e) {
            if (!dragState.isDragging || !dragState.draggedCard || !dragState.placeholder) return;
            
            const item = dragState.draggedCard;
            item.style.top = (e.clientY - dragState.offsetY) + 'px';
            
            const container = document.getElementById('cards-container');
            const items = Array.from(container.querySelectorAll('.sortable-item:not(.dragging)'));
            
            let insertBefore = null;
            const dragY = e.clientY;
            
            for (const otherItem of items) {
                const rect = otherItem.getBoundingClientRect();
                const middleY = rect.top + rect.height / 2;
                
                if (dragY < middleY) {
                    insertBefore = otherItem;
                    break;
                }
            }
            
            // Проверяем нужно ли перемещать placeholder
            const needsMove = insertBefore 
                ? dragState.placeholder.nextSibling !== insertBefore
                : dragState.placeholder.nextSibling !== null;
            
            if (needsMove) {
                // FLIP: First - сохраняем позиции
                const positions = new Map();
                items.forEach(i => {
                    positions.set(i, i.getBoundingClientRect().top);
                });
                
                // Перемещаем placeholder
                if (insertBefore) {
                    container.insertBefore(dragState.placeholder, insertBefore);
                } else {
                    container.appendChild(dragState.placeholder);
                }
                
                // FLIP: Last, Invert, Play
                items.forEach(i => {
                    const oldTop = positions.get(i);
                    const newTop = i.getBoundingClientRect().top;
                    const delta = oldTop - newTop;
                    
                    if (delta !== 0) {
                        // Отключаем transition, ставим начальную позицию
                        i.style.transition = 'none';
                        i.style.transform = `translateY(${delta}px)`;
                        
                        // Форсируем reflow
                        i.offsetHeight;
                        
                        // Включаем transition и анимируем к конечной позиции
                        i.style.transition = 'transform 0.15s ease-out';
                        i.style.transform = 'translateY(0)';
                    }
                });
                
                // Обновляем номера блоков визуально
                updateBlockNumbersVisually();
            }
            
            // Автоскролл
            const scrollContainer = document.querySelector('.main-scroll-container');
            if (scrollContainer) {
                const containerRect = scrollContainer.getBoundingClientRect();
                if (e.clientY < containerRect.top + 50) {
                    scrollContainer.scrollTop -= 10;
                } else if (e.clientY > containerRect.bottom - 50) {
                    scrollContainer.scrollTop += 10;
                }
            }
        }
        
        function endDrag(e) {
            if (!dragState.isDragging || !dragState.draggedCard || !dragState.placeholder) return;
            
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', endDrag);
            
            const item = dragState.draggedCard;
            const container = document.getElementById('cards-container');
            const placeholder = dragState.placeholder;
            
            // Сбрасываем transform у всех элементов
            container.querySelectorAll('.sortable-item').forEach(i => {
                i.style.transition = '';
                i.style.transform = '';
            });
            
            // Вставляем элемент на место placeholder
            container.insertBefore(item, placeholder);
            placeholder.remove();
            
            // Сбрасываем стили
            item.style.position = '';
            item.style.width = '';
            item.style.left = '';
            item.style.top = '';
            item.style.zIndex = '';
            item.style.pointerEvents = '';
            item.classList.remove('dragging');
            
            dragState.isDragging = false;
            dragState.draggedCard = null;
            dragState.placeholder = null;
        }
        
        function saveBlocksOrder() {
            saveToUndoStack(); // Сохраняем состояние перед изменением порядка
            const container = document.getElementById('cards-container');
            if (!container) return;
            
            const tabs = getAllTabs();
            const tab = tabs[currentTab];
            
            if (!tab || !tab.items) return;
            
            // Получаем все sortable элементы в новом порядке
            const sortableElements = Array.from(container.querySelectorAll(':scope > .sortable-item'));
            
            // Создаём новый массив items в соответствии с порядком элементов
            const newItems = [];
            let blockNumber = 1;
            
            sortableElements.forEach(element => {
                const itemId = element.dataset.itemId;
                const itemType = element.dataset.itemType;
                
                if (itemType === 'block') {
                    const item = tab.items.find(i => i.id === itemId);
                    if (item) {
                        newItems.push(item);
                        
                        // Обновляем номер в UI и dataset
                        element.dataset.sectionNumber = String(blockNumber);
                        const numberBadge = element.querySelector('.block-number');
                        if (numberBadge) {
                            numberBadge.textContent = String(blockNumber);
                        }
                        // Обновляем номер в textarea
                        const textarea = element.querySelector('.textarea-content');
                        if (textarea) {
                            textarea.dataset.number = String(blockNumber);
                        }
                        blockNumber++;
                    }
                } else if (itemType === 'chatBreak') {
                    const item = tab.items.find(i => i.id === itemId);
                    if (item) {
                        newItems.push(item);
                    }
                }
            });
            
            // Контент хранится по ID блока, не нужно переносить
            
            tab.items = newItems;
            saveAllTabs(tabs);
            saveToUndoStack(); // Сохраняем состояние после изменения
        }
        
        // Функция для обновления номеров блоков визуально (при перетаскивании)
        function updateBlockNumbersVisually() {
            const container = document.getElementById('cards-container');
            if (!container) return;
            
            // Получаем все элементы включая placeholder
            const allElements = Array.from(container.children);
            let blockNumber = 1;
            
            allElements.forEach(element => {
                // Если это placeholder - присваиваем номер перетаскиваемому элементу
                if (element.classList.contains('drag-placeholder')) {
                    if (dragState.draggedCard && dragState.draggedCard.dataset.itemType === 'block') {
                        const numberBadge = dragState.draggedCard.querySelector('.block-number');
                        if (numberBadge) {
                            numberBadge.textContent = String(blockNumber);
                        }
                        blockNumber++;
                    }
                } else if (element.classList.contains('sortable-item') && !element.classList.contains('dragging')) {
                    if (element.dataset.itemType === 'block') {
                        const numberBadge = element.querySelector('.block-number');
                        if (numberBadge) {
                            numberBadge.textContent = String(blockNumber);
                        }
                        blockNumber++;
                    }
                }
            });
        }
        
        // --- ИНСТРУКЦИИ БЛОКОВ (wrappers) ---
        function removeBlockInstruction(blockNumber) {
            // saveToUndoStack вызывается внутри updateBlockInstruction
            updateBlockInstruction(currentTab, blockNumber, null);
            loadPrompts();
        }
        
        function addBlockInstruction(blockNumber, type = 'info') {
            // saveToUndoStack вызывается внутри updateBlockInstruction
            const instruction = {
                type: type,
                text: type === 'keyword-replace' ? 'Заменить ключевое слово' : 'Инструкция'
            };
            updateBlockInstruction(currentTab, blockNumber, instruction);
            loadPrompts();
        }

        /**
         * Создает карточку промпта.
         * @param {Object} section - Объект секции промпта.
         * @returns {HTMLDivElement} Карточка промпта.
         */
        // Глобальная переменная для отслеживания текущего редактируемого блока
        let currentEditingCard = null;
        let currentDisableEditing = null;
        
        function createPromptCard(section) {
            const card = document.createElement('div');
            const hasInstruction = section.instruction ? 'has-instruction' : '';
            card.className = `prompt-card sortable-item bg-white rounded-2xl shadow-sm overflow-hidden flex flex-col group ${hasInstruction}`;
            card.dataset.sectionNumber = section.number;
            card.dataset.itemId = section.id;
            card.dataset.itemType = 'block';

            const displayTitle = section.title || `Блок ${section.number}`;
            
            const safeTitle = escapeHtml(displayTitle);
            
            // Проверяем режим редактирования
            const isEditableBlock = isEditMode;
            
            // Заголовок
            const header = document.createElement('div');
            header.className = 'card-header px-6 py-4 border-b border-gray-100 bg-gray-50/50 flex justify-between items-center transition-colors select-none';
            
            // Генерируем HTML заголовка в зависимости от режима
            let titleHtml;
            if (isEditableBlock) {
                titleHtml = `<input type="text" class="block-title-input font-semibold text-gray-800 bg-transparent border-b border-dashed border-gray-300 focus:border-claude-accent focus:outline-none px-1 w-64 max-w-xs" value="${safeTitle}" data-number="${section.number}">`;
            } else {
                titleHtml = `<h2 class="font-semibold text-gray-800">${safeTitle}</h2>`;
            }
            
            let deleteButtonHtml = '';
            if (isEditableBlock) {
                deleteButtonHtml = `
                    <button class="delete-block-btn text-xs font-medium text-red-400 hover:text-red-600 flex items-center gap-1 transition-colors" data-number="${section.number}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                        Удалить
                    </button>
                `;
            }
            
            header.innerHTML = `
                <div class="flex items-center gap-3">
                    ${isEditableBlock ? `
                    <div class="drag-handle text-gray-300" title="Перетащить">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M4 8h16M4 16h16" />
                        </svg>
                    </div>
                    ` : ''}
                    <!-- Используем новый акцентный цвет и белый текст -->
                    <span class="block-number flex items-center justify-center w-8 h-8 rounded-full bg-claude-accent text-white font-bold text-sm">
                        ${section.number}
                    </span>
                    ${titleHtml}
                </div>
                <div class="header-controls flex items-center gap-3">
                    ${deleteButtonHtml}
                    <!-- Кнопка редактирования -->
                    <button id="edit-btn-${section.number}" class="edit-button text-xs font-medium text-gray-400 uppercase tracking-wider hover:text-gray-700 flex items-center gap-1 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                        </svg>
                        Редактировать
                    </button>
                    <!-- Кнопка копирования -->
                    <button id="copy-btn-${section.number}" class="copy-button text-xs font-medium text-gray-400 uppercase tracking-wider hover:text-gray-700 flex items-center gap-1 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                        </svg>
                        Скопировать
                    </button>
                </div>
            `;
            
            // Текстовое поле (только для чтения)
            const textarea = document.createElement('textarea');
            textarea.id = `prompt-text-${section.number}`; 
            textarea.className = 'w-full p-6 text-gray-600 text-sm leading-relaxed focus:outline-none transition-colors textarea-content bg-white cursor-default'; 
            textarea.value = section.content; // Инициализация содержимым шаблона
            textarea.spellcheck = false;
            textarea.readOnly = true; // Запрещаем редактирование
            // Добавление пользовательского атрибута данных
            textarea.dataset.number = section.number;
            textarea.dataset.itemId = section.id; // ID блока для хранения в localStorage
            
            // Отслеживаем активный textarea для вставки из панели инструментов
            textarea.addEventListener('focus', () => {
                activeTextarea = textarea;
                showPromptTools();
            });

            // Функция выключения редактирования
            const disableEditing = () => {
                if (textarea.readOnly) return;
                textarea.readOnly = true;
                textarea.classList.remove('editing-mode');
                textarea.classList.add('bg-white', 'cursor-default');
                card.classList.remove('editing');
                editButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                    </svg>
                    Редактировать
                `;
                editButton.classList.remove('text-claude-accent');
                editButton.classList.add('text-gray-400');
                // Сбрасываем глобальную переменную
                if (currentEditingCard === card) {
                    currentEditingCard = null;
                    currentDisableEditing = null;
                }
            };

            // Функция включения редактирования
            const enableEditing = () => {
                if (!textarea.readOnly) return;
                
                // Закрываем предыдущее редактирование, если есть
                if (currentEditingCard && currentEditingCard !== card && currentDisableEditing) {
                    currentDisableEditing();
                }
                
                const currentScrollTop = textarea.scrollTop;
                textarea.readOnly = false;
                textarea.classList.add('editing-mode');
                textarea.classList.remove('bg-white', 'cursor-default');
                card.classList.add('editing');
                textarea.focus();
                
                // Устанавливаем текущий редактируемый блок
                currentEditingCard = card;
                currentDisableEditing = disableEditing;
                
                // Если скролл в начале - курсор в начало, иначе сохраняем позицию
                if (currentScrollTop < 10) {
                    textarea.setSelectionRange(0, 0);
                    textarea.scrollTop = 0;
                } else {
                    // Восстанавливаем позицию скролла и ставим курсор в начало видимой области
                    textarea.scrollTop = currentScrollTop;
                    // Находим примерную позицию символа в видимой области
                    const lineHeight = parseInt(getComputedStyle(textarea).lineHeight) || 20;
                    const visibleLine = Math.floor(currentScrollTop / lineHeight);
                    const lines = textarea.value.split('\n');
                    let charPos = 0;
                    for (let i = 0; i < visibleLine && i < lines.length; i++) {
                        charPos += lines[i].length + 1;
                    }
                    textarea.setSelectionRange(charPos, charPos);
                }
                
                editButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                    </svg>
                    Готово
                `;
                editButton.classList.add('text-claude-accent');
                editButton.classList.remove('text-gray-400');
                // Эффект вспышки
                editButton.style.backgroundColor = '#f4e7e3';
                setTimeout(() => {
                    editButton.style.backgroundColor = '';
                }, 200);
            };

            // Действие редактирования
            const editButton = header.querySelector(`#edit-btn-${section.number}`);
            editButton.addEventListener('click', (e) => {
                e.stopPropagation();
                if (textarea.readOnly) {
                    enableEditing();
                } else {
                    disableEditing();
                }
            });

            // Действие копирования
            const copyButton = header.querySelector(`#copy-btn-${section.number}`);
            const copyToClipboard = async () => {
                const currentScroll = textarea.scrollTop;
                const text = textarea.value;
                
                const onSuccess = () => {
                    showToast();
                    // Используем очень светлый тон нового цвета для вспышки
                    copyButton.style.backgroundColor = '#f4e7e3'; 
                    setTimeout(() => {
                        copyButton.style.backgroundColor = '';
                    }, 200);
                };
                
                try {
                    // Современный Clipboard API
                    await navigator.clipboard.writeText(text);
                    onSuccess();
                } catch (err) {
                    // Fallback для старых браузеров или при ограничениях безопасности
                    try {
                        textarea.select();
                        const successful = document.execCommand('copy');
                        if (successful) {
                            onSuccess();
                        } else {
                            console.error('Не удалось скопировать. Пожалуйста, скопируйте вручную.');
                        }
                    } catch (fallbackErr) {
                        console.error('Не удалось скопировать', fallbackErr);
                    }
                }
                // Снимаем выделение
                window.getSelection().removeAllRanges();
                textarea.setSelectionRange(0, 0);
                textarea.blur();
                textarea.scrollTop = currentScroll;
            };

            copyButton.addEventListener('click', copyToClipboard);
            
            // Обработчики для режима редактирования кастомной вкладки
            const deleteBlockBtn = header.querySelector('.delete-block-btn');
            if (deleteBlockBtn) {
                deleteBlockBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const blocks = getTabBlocks(currentTab);
                    if (blocks.length <= 1) {
                        showAlert('Нельзя удалить последний блок');
                        return;
                    }
                    if (confirm('Удалить этот блок?')) {
                        removeBlockFromTab(currentTab, section.number);
                        loadPrompts();
                    }
                });
            }
            
            const titleInput = header.querySelector('.block-title-input');
            if (titleInput) {
                titleInput.addEventListener('change', (e) => {
                    updateBlockTitle(currentTab, section.number, e.target.value);
                });
                titleInput.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }

            card.appendChild(header);

            // --- ИНСТРУКЦИИ БЛОКА ---
            // Функция для получения SVG иконки по типу
            function getInstructionIconSvg(iconType) {
                const icons = {
                    info: `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                    </svg>`,
                    paperclip: `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z" clip-rule="evenodd" />
                    </svg>`,
                    edit: `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 flex-shrink-0" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                    </svg>`,
                    refresh: `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
                    </svg>`
                };
                return icons[iconType] || icons.info;
            }
            
            // Отображаем инструкцию если она есть в конфиге блока
            if (section.instruction) {
                const instructionStrip = document.createElement('div');
                // justify-between только в режиме редактирования
                const justifyClass = isEditMode ? 'justify-between' : '';
                instructionStrip.className = `instruction-wrapper bg-claude-light text-claude-accent text-sm font-medium py-2 px-6 flex items-center gap-2 ${justifyClass}`; 
                
                let instructionContent = '';
                const safeInstructionText = escapeHtml(section.instruction.text || '');
                const iconType = section.instruction.icon || 'info';
                const iconSvg = getInstructionIconSvg(iconType);
                
                if (isEditMode) {
                    // Режим редактирования - поле ввода и кнопка удаления
                    instructionContent = `
                        <div class="flex items-center gap-2 flex-1">
                            ${iconSvg}
                            <input type="text" 
                                   class="instruction-input flex-1" 
                                   value="${safeInstructionText}" 
                                   data-block-number="${section.number}"
                                   placeholder="Текст инструкции">
                        </div>
                        <button class="remove-instruction-btn text-red-400 hover:text-red-600 p-1" data-block-number="${section.number}" title="Удалить инструкцию">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    `;
                } else if (section.instruction.type === 'input' && section.instruction.fields && section.instruction.fields.length > 0) {
                    // Инструкция с настроенными полями - кликабельная кнопка с текстом
                    instructionContent = `
                        ${iconSvg}
                        <button class="field-input-btn font-bold underline hover:no-underline transition-colors focus:outline-none">
                            ${safeInstructionText}
                        </button>
                    `;
                } else if (section.instruction.type === 'keyword-replace') {
                    // Кнопка для замены ключевого слова
                    instructionContent = `
                        ${getInstructionIconSvg('edit')}
                        <button id="replace-keyword-btn-${section.number}" 
                                class="font-bold underline hover:no-underline transition-colors focus:outline-none">
                            ${safeInstructionText}
                        </button>
                    `;
                } else {
                    // Обычная информационная инструкция
                    instructionContent = `
                        ${iconSvg}
                        <span>${safeInstructionText}</span>
                    `;
                }

                instructionStrip.innerHTML = instructionContent;
                
                // Обработчики для режима редактирования
                if (isEditMode) {
                    const instructionInput = instructionStrip.querySelector('.instruction-input');
                    if (instructionInput) {
                        instructionInput.addEventListener('change', (e) => {
                            const blockNum = e.target.dataset.blockNumber;
                            const newText = e.target.value.trim();
                            if (newText) {
                                updateBlockInstruction(currentTab, blockNum, { 
                                    type: section.instruction.type,
                                    icon: section.instruction.icon || 'info',
                                    text: newText 
                                });
                            }
                        });
                        instructionInput.addEventListener('click', (e) => e.stopPropagation());
                        instructionInput.addEventListener('focus', () => {
                            activeInstructionBlock = section.number;
                            showInstructionTools();
                        });
                    }
                    
                    const removeBtn = instructionStrip.querySelector('.remove-instruction-btn');
                    if (removeBtn) {
                        removeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const blockNum = e.currentTarget.dataset.blockNumber;
                            removeBlockInstruction(blockNum);
                        });
                    }
                } else if (section.instruction.type === 'keyword-replace' || section.instruction.type === 'input') {
                    // Слушатель для кнопки замены/ввода
                    instructionStrip.addEventListener('click', (e) => {
                        if (e.target.closest('button') || e.target.closest('.field-input-btn')) {
                            showDynamicInputModal(section.number);
                        }
                    });
                }
                
                card.appendChild(instructionStrip);
            } else if (isEditMode) {
                // Кнопка добавления инструкции (показывается только в режиме редактирования)
                const addInstructionStrip = document.createElement('div');
                addInstructionStrip.className = 'add-instruction-btn bg-gray-50 text-gray-400 hover:text-claude-accent hover:bg-claude-light text-sm py-2 px-6 flex items-center gap-2 cursor-pointer transition-colors';
                addInstructionStrip.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
                    </svg>
                    <span>Добавить инструкцию</span>
                `;
                addInstructionStrip.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addBlockInstruction(section.number, 'info');
                });
                card.appendChild(addInstructionStrip);
            }
            // --- КОНЕЦ: ИНСТРУКЦИИ БЛОКА ---

            // Обёртка для textarea с кастомным скроллбаром
            const textareaWrapper = document.createElement('div');
            textareaWrapper.className = 'textarea-wrapper';
            textareaWrapper.style.position = 'relative';
            
            // Кастомный скроллбар
            const customScrollbar = document.createElement('div');
            customScrollbar.className = 'custom-scrollbar';
            customScrollbar.innerHTML = '<div class="custom-scrollbar-thumb"></div>';
            
            textareaWrapper.appendChild(textarea);
            textareaWrapper.appendChild(customScrollbar);
            card.appendChild(textareaWrapper);
            
            // Инициализация кастомного скроллбара
            initCustomScrollbar(textarea, customScrollbar);
            
            // Важно: вызываем autoResizeTextarea для начальной установки высоты
            window.requestAnimationFrame(() => autoResizeTextarea(textarea));
            
            return card;
        }

        // --- ЛОГИКА МОДАЛЬНОГО ОКНА ---

        /**
         * Показывает модальное окно.
         */
        function showModal() {
            // Модальное окно только для вкладки Default
            if (currentTab !== 'default') return;
            
            closeAllModals();
            
            const modal = document.getElementById('keyword-modal');
            const textarea = document.getElementById(`prompt-text-${KEYWORD_SECTION_NUMBER}`);
            
            // Поиск текущего ключевого слова
            const keywordRegex = /по ключевому слову "([^"]*)"/;
            const keywordMatch = textarea.value.match(keywordRegex);
            const currentKeyword = keywordMatch ? keywordMatch[1] : '';

            // Поиск текущего вида спорта (контекста)
            const sportRegex = /в контексте ([а-яёa-z]+)/i;
            const sportMatch = textarea.value.match(sportRegex);
            const hasContext = sportMatch !== null;
            const currentSport = sportMatch ? sportMatch[1] : 'example';

            const keywordInput = document.getElementById('new-keyword-input');
            const sportInput = document.getElementById('new-sport-input');
            const contextWrapper = document.getElementById('context-field-wrapper');
            const addContextBtn = document.getElementById('add-context-btn-wrapper');
            
            keywordInput.value = currentKeyword;
            sportInput.value = currentSport;
            
            // Показываем/скрываем поле контекста в зависимости от наличия в тексте
            if (hasContext) {
                contextWrapper.classList.remove('hidden');
                addContextBtn.classList.add('hidden');
            } else {
                contextWrapper.classList.add('hidden');
                addContextBtn.classList.remove('hidden');
            }

            modal.classList.add('open');
            keywordInput.focus();
        }

        /**
         * Скрывает модальное окно.
         */
        function hideModal() {
            document.getElementById('keyword-modal').classList.remove('open');
        }
        
        /**
         * Устанавливает слушатели событий для кнопок модального окна и оверлея.
         */
        function setupModalListeners() {
            const applyButton = document.getElementById('apply-keyword-btn');
            applyButton.addEventListener('click', applyKeywordReplacement);
            
            const keywordInput = document.getElementById('new-keyword-input');
            keywordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const contextWrapper = document.getElementById('context-field-wrapper');
                    if (!contextWrapper.classList.contains('hidden')) {
                        document.getElementById('new-sport-input').focus();
                    } else {
                        applyKeywordReplacement();
                    }
                }
            });
            
            const sportInput = document.getElementById('new-sport-input');
            sportInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    applyKeywordReplacement();
                }
            });
            
            // Кнопка удаления контекста
            const removeContextBtn = document.getElementById('remove-context-btn');
            removeContextBtn.addEventListener('click', () => {
                document.getElementById('context-field-wrapper').classList.add('hidden');
                document.getElementById('add-context-btn-wrapper').classList.remove('hidden');
            });
            
            // Кнопка добавления контекста
            const addContextBtn = document.getElementById('add-context-btn');
            addContextBtn.addEventListener('click', () => {
                document.getElementById('context-field-wrapper').classList.remove('hidden');
                document.getElementById('add-context-btn-wrapper').classList.add('hidden');
                document.getElementById('new-sport-input').focus();
            });

            // ИСПРАВЛЕНИЕ: Добавление слушателя mousedown на оверлей для предотвращения бага с выделением текста.
            const modalOverlay = document.getElementById('keyword-modal');
            modalOverlay.addEventListener('mousedown', (event) => {
                // Закрываем только если нажатие произошло именно на оверлее, а не на контенте модального окна
                if (event.target.id === 'keyword-modal') {
                    hideModal();
                }
            });
        }


        /**
         * Применяет замену ключевого слова в тексте блока 2.
         */
        function applyKeywordReplacement() {
            const newKeywordInput = document.getElementById('new-keyword-input');
            const newSportInput = document.getElementById('new-sport-input');
            const contextWrapper = document.getElementById('context-field-wrapper');
            const contextVisible = !contextWrapper.classList.contains('hidden');
            
            // Удаляем кавычки из ввода для защиты от поломки регулярок
            const newKeyword = newKeywordInput.value.trim().replace(/"/g, '');
            const newSport = newSportInput.value.trim().replace(/"/g, '');

            const textarea = document.getElementById(`prompt-text-${KEYWORD_SECTION_NUMBER}`);
            let content = textarea.value;
            let changed = false;
            
            // Замена ключевого слова
            if (newKeyword) {
                const keywordRegex = /по ключевому слову "([^"]*)"/s; 
                const replacementKeyword = `по ключевому слову "${newKeyword}"`;
                const newContent = content.replace(keywordRegex, replacementKeyword);
                if (newContent !== content) {
                    content = newContent;
                    changed = true;
                }
            }
            
            // Проверяем, есть ли контекст в тексте
            const sportRegex = /в контексте [а-яёa-z]+/i;
            const hasContextInText = sportRegex.test(content);
            
            if (contextVisible && newSport) {
                // Контекст включен - добавляем или обновляем
                if (hasContextInText) {
                    // Обновляем существующий контекст
                    const replacementSport = `в контексте ${newSport}`;
                    const newContent = content.replace(sportRegex, replacementSport);
                    if (newContent !== content) {
                        content = newContent;
                        changed = true;
                    }
                } else {
                    // Добавляем контекст после "в тематике спортивных ставок"
                    const themePattern = /в тематике спортивных ставок/;
                    const newContent = content.replace(themePattern, `$& в контексте ${newSport}`);
                    if (newContent !== content) {
                        content = newContent;
                        changed = true;
                    }
                }
            } else if (!contextVisible && hasContextInText) {
                // Контекст выключен - удаляем из текста
                const removeContextRegex = / в контексте [а-яёa-z]+/i;
                const newContent = content.replace(removeContextRegex, '');
                if (newContent !== content) {
                    content = newContent;
                    changed = true;
                }
            }
            
            if (changed) {
                textarea.value = content;
                autoResizeTextarea(textarea);
                saveToLocalStorage(textarea.dataset.itemId, content);
                saveToUndoStack();
            }

            hideModal();
        }
        
        // ============================================
        // КОНСТРУКТОР ПОЛЕЙ ВВОДА
        // ============================================
        
        let currentConstructorBlockNumber = null;
        
        function showInputConstructorModal(blockNumber) {
            currentConstructorBlockNumber = blockNumber;
            closeAllModals();
            
            const blocks = getTabBlocks(currentTab);
            const block = blocks.find(b => b.number === blockNumber);
            const instruction = block?.instruction;
            
            // Заполняем текст инструкции
            const instructionTextInput = document.getElementById('constructor-instruction-text');
            instructionTextInput.value = instruction?.text || '';
            
            // Заполняем поля конструктора
            const fieldsContainer = document.getElementById('constructor-fields');
            fieldsContainer.innerHTML = '';
            
            if (instruction?.fields && instruction.fields.length > 0) {
                instruction.fields.forEach((field, index) => {
                    addConstructorFieldElement(field, index);
                });
            } else {
                // Добавляем одно пустое поле по умолчанию
                addConstructorFieldElement({ label: '', placeholder: '', pattern: '', optional: false }, 0);
            }
            
            document.getElementById('input-constructor-modal').classList.add('open');
            instructionTextInput.focus();
        }
        
        function hideInputConstructorModal() {
            document.getElementById('input-constructor-modal').classList.remove('open');
            currentConstructorBlockNumber = null;
        }
        
        function addConstructorFieldElement(fieldData = {}, index = null) {
            const container = document.getElementById('constructor-fields');
            if (index === null) {
                index = container.children.length;
            }
            
            // Ограничение на 4 поля
            if (index >= 4) {
                return;
            }
            
            const fieldDiv = document.createElement('div');
            fieldDiv.className = 'constructor-field bg-gray-50 rounded-lg p-3 border border-gray-200';
            fieldDiv.dataset.fieldIndex = index;
            
            // Первое поле не может быть опциональным
            const optionalCheckbox = index === 0 ? '' : `
                    <label class="flex items-center gap-2 text-xs text-gray-600 cursor-pointer">
                        <input type="checkbox" class="field-optional rounded border-gray-300 text-claude-accent focus:ring-claude-accent" ${fieldData.optional ? 'checked' : ''}>
                        <span>Опциональное поле (можно скрыть)</span>
                    </label>`;
            
            fieldDiv.innerHTML = `
                <div class="flex justify-between items-start mb-2">
                    <span class="text-xs font-medium text-gray-500">Поле ${index + 1}</span>
                    <button type="button" class="remove-field-btn text-gray-400 hover:text-red-500 transition-colors" title="Удалить поле">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
                <div class="space-y-2">
                    <input type="text" class="field-label w-full px-3 py-1.5 text-sm border border-gray-200 rounded focus:border-claude-accent focus:outline-none" 
                           placeholder="Название поля (например: Ключевое слово)" value="${escapeHtml(fieldData.label || '')}">
                    <input type="text" class="field-placeholder w-full px-3 py-1.5 text-sm border border-gray-200 rounded focus:border-claude-accent focus:outline-none" 
                           placeholder="example" value="${escapeHtml(fieldData.placeholder || '')}">
                    <input type="text" class="field-prefix w-full px-3 py-1.5 text-sm border border-gray-200 rounded focus:border-claude-accent focus:outline-none" 
                           placeholder="Фраза перед заменяемым словом" value="${escapeHtml(fieldData.prefix || '')}">
                    ${optionalCheckbox}
                </div>
            `;
            
            // Обработчик удаления поля
            fieldDiv.querySelector('.remove-field-btn').addEventListener('click', () => {
                if (container.children.length > 1) {
                    fieldDiv.remove();
                    reindexConstructorFields();
                    updateAddFieldButton();
                }
            });
            
            container.appendChild(fieldDiv);
            updateAddFieldButton();
        }
        
        function updateAddFieldButton() {
            const container = document.getElementById('constructor-fields');
            const addBtn = document.getElementById('add-constructor-field-btn');
            if (container.children.length >= 4) {
                addBtn.classList.add('hidden');
            } else {
                addBtn.classList.remove('hidden');
            }
        }
        
        function reindexConstructorFields() {
            const container = document.getElementById('constructor-fields');
            Array.from(container.children).forEach((field, index) => {
                field.dataset.fieldIndex = index;
                field.querySelector('.text-xs.font-medium').textContent = `Поле ${index + 1}`;
                
                // Первое поле не может быть опциональным
                const optionalCheckbox = field.querySelector('.field-optional');
                const optionalLabel = optionalCheckbox?.closest('label');
                
                if (index === 0 && optionalLabel) {
                    optionalLabel.remove();
                } else if (index > 0 && !optionalCheckbox) {
                    // Добавляем чекбокс если его нет
                    const spaceDiv = field.querySelector('.space-y-2');
                    const label = document.createElement('label');
                    label.className = 'flex items-center gap-2 text-xs text-gray-600 cursor-pointer';
                    label.innerHTML = `
                        <input type="checkbox" class="field-optional rounded border-gray-300 text-claude-accent focus:ring-claude-accent">
                        <span>Опциональное поле (можно скрыть)</span>
                    `;
                    spaceDiv.appendChild(label);
                }
            });
        }
        
        function saveConstructorFields() {
            if (!currentConstructorBlockNumber) return;
            
            // Получаем текст инструкции
            const instructionText = document.getElementById('constructor-instruction-text').value.trim();
            if (!instructionText) {
                alert('Введите текст сноски');
                return;
            }
            
            const container = document.getElementById('constructor-fields');
            const fields = [];
            
            container.querySelectorAll('.constructor-field').forEach((fieldEl, idx) => {
                const label = fieldEl.querySelector('.field-label').value.trim();
                const placeholder = fieldEl.querySelector('.field-placeholder').value.trim();
                const prefix = fieldEl.querySelector('.field-prefix').value;
                const optionalCheckbox = fieldEl.querySelector('.field-optional');
                // Первое поле (idx=0) не может быть опциональным
                const optional = idx === 0 ? false : (optionalCheckbox?.checked || false);
                
                if (label || prefix) {
                    fields.push({ label, placeholder, prefix, optional });
                }
            });
            
            // Получаем текущую инструкцию и обновляем
            const blocks = getTabBlocks(currentTab);
            const block = blocks.find(b => b.number === currentConstructorBlockNumber);
            
            const updatedInstruction = {
                type: 'input',
                icon: block?.instruction?.icon || 'edit',
                text: instructionText,
                fields: fields
            };
            
            updateBlockInstruction(currentTab, currentConstructorBlockNumber, updatedInstruction);
            hideInputConstructorModal();
            loadPrompts();
        }
        
        // ============================================
        // ДИНАМИЧЕСКОЕ МОДАЛЬНОЕ ОКНО (RUNTIME)
        // ============================================
        
        let currentDynamicInputBlock = null;
        
        function showDynamicInputModal(blockNumber) {
            currentDynamicInputBlock = blockNumber;
            closeAllModals();
            
            const blocks = getTabBlocks(currentTab);
            const block = blocks.find(b => b.number === blockNumber);
            const instruction = block?.instruction;
            
            if (!instruction?.fields || instruction.fields.length === 0) {
                // Если полей нет - показываем старую модалку keyword
                showKeywordModal(blockNumber);
                return;
            }
            
            // Заголовок
            document.getElementById('dynamic-modal-title').textContent = instruction.text || 'Ввод данных';
            
            // Генерируем поля
            const fieldsContainer = document.getElementById('dynamic-modal-fields');
            fieldsContainer.innerHTML = '';
            
            // Получаем текст блока для извлечения текущих значений
            const textarea = document.getElementById(`prompt-text-${blockNumber}`);
            const content = textarea?.value || '';
            
            instruction.fields.forEach((field, index) => {
                const fieldWrapper = document.createElement('div');
                fieldWrapper.className = 'dynamic-field';
                fieldWrapper.dataset.fieldIndex = index;
                
                // suffix = prefix следующего поля, или конец слова
                const nextField = instruction.fields[index + 1];
                const suffix = nextField?.prefix || '';
                
                // Извлекаем текущее значение
                let currentValue = '';
                let foundInText = false;
                
                if (field.prefix) {
                    // Берём последнее введённое значение из localStorage
                    const blockId = block?.id || blockNumber;
                    const storageKey = `field-value-${currentTab}-${blockId}-${index}`;
                    const savedValue = localStorage.getItem(storageKey);
                    
                    if (savedValue) {
                        currentValue = savedValue;
                        foundInText = true;
                    } else {
                        // Первый раз — берём placeholder или example
                        currentValue = field.placeholder || 'example';
                        foundInText = true;
                    }
                }
                
                const isHidden = field.optional && !foundInText;
                
                if (field.optional) {
                    // Опциональное поле с кнопкой показа/скрытия
                    fieldWrapper.innerHTML = `
                        <div class="optional-field-toggle ${isHidden ? '' : 'hidden'} mb-2">
                            <button type="button" class="show-optional-field flex items-center gap-1 text-sm text-gray-500 hover:text-claude-accent transition-colors">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                                </svg>
                                <span>Добавить ${field.label.toLowerCase()}</span>
                            </button>
                        </div>
                        <div class="optional-field-content ${isHidden ? 'hidden' : ''} mb-2">
                            <label class="block text-sm font-medium text-gray-700 mb-1">${escapeHtml(field.label)}</label>
                            <div class="flex gap-2">
                                <input type="text" class="dynamic-input flex-1 px-4 py-2 border-2 border-gray-200 rounded-lg focus:border-claude-accent focus:outline-none text-gray-700 transition-colors"
                                       data-prefix="${escapeHtml(field.prefix || '')}"
                                       data-suffix="${escapeHtml(suffix)}"
                                       data-optional="true"
                                       data-found="${foundInText}"
                                       data-original-value="${escapeHtml(currentValue)}"
                                       data-field-index="${index}"
                                       placeholder="${escapeHtml(field.placeholder || 'example')}"
                                       value="${escapeHtml(currentValue)}">
                                <button type="button" class="hide-optional-field px-3 py-2 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors" title="Убрать">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    // Обработчики показа/скрытия
                    setTimeout(() => {
                        const showBtn = fieldWrapper.querySelector('.show-optional-field');
                        const hideBtn = fieldWrapper.querySelector('.hide-optional-field');
                        const toggle = fieldWrapper.querySelector('.optional-field-toggle');
                        const content = fieldWrapper.querySelector('.optional-field-content');
                        
                        showBtn?.addEventListener('click', () => {
                            toggle.classList.add('hidden');
                            content.classList.remove('hidden');
                            content.querySelector('input')?.focus();
                        });
                        
                        hideBtn?.addEventListener('click', () => {
                            toggle.classList.remove('hidden');
                            content.classList.add('hidden');
                            content.querySelector('input').value = '';
                        });
                    }, 0);
                } else {
                    // Обычное обязательное поле
                    fieldWrapper.innerHTML = `
                        <div class="mb-2">
                            <label class="block text-sm font-medium text-gray-700 mb-1">${escapeHtml(field.label)}</label>
                            <input type="text" class="dynamic-input w-full px-4 py-2 border-2 border-gray-200 rounded-lg focus:border-claude-accent focus:outline-none text-gray-700 transition-colors"
                                   data-prefix="${escapeHtml(field.prefix || '')}"
                                   data-suffix="${escapeHtml(suffix)}"
                                   data-found="${foundInText}"
                                   data-original-value="${escapeHtml(currentValue)}"
                                   data-field-index="${index}"
                                   placeholder="${escapeHtml(field.placeholder || 'example')}"
                                   value="${escapeHtml(currentValue)}">
                        </div>
                    `;
                }
                
                fieldsContainer.appendChild(fieldWrapper);
            });
            
            document.getElementById('dynamic-input-modal').classList.add('open');
            
            // Фокус на первое поле
            setTimeout(() => {
                fieldsContainer.querySelector('.dynamic-input:not([data-optional="true"])')?.focus();
            }, 100);
        }
        
        function hideDynamicInputModal() {
            document.getElementById('dynamic-input-modal').classList.remove('open');
            currentDynamicInputBlock = null;
        }
        
        function applyDynamicInput() {
            if (!currentDynamicInputBlock) return;
            
            const textarea = document.getElementById(`prompt-text-${currentDynamicInputBlock}`);
            if (!textarea) return;
            
            let content = textarea.value;
            let changed = false;
            
            const fieldsContainer = document.getElementById('dynamic-modal-fields');
            
            fieldsContainer.querySelectorAll('.dynamic-input').forEach((input) => {
                const prefix = input.dataset.prefix;
                const originalValue = input.dataset.originalValue || '';
                const fieldIndex = input.dataset.fieldIndex;
                let newValue = input.value.trim();
                if (!newValue) {
                    newValue = input.placeholder || 'example';
                }
                const isOptional = input.dataset.optional === 'true';
                const isHidden = input.closest('.optional-field-content')?.classList.contains('hidden');
                
                if (!prefix) return;
                
                // Получаем ID блока для сохранения
                const blocks = getTabBlocks(currentTab);
                const block = blocks.find(b => b.number === currentDynamicInputBlock);
                const blockId = block?.id || currentDynamicInputBlock;
                const storageKey = `field-value-${currentTab}-${blockId}-${fieldIndex}`;
                
                if (isOptional && isHidden) {
                    // Опциональное поле скрыто — удаляем из текста
                    if (originalValue) {
                        // Пробуем разные форматы (учитываем что prefix может заканчиваться на пробел)
                        const spacer = prefix.endsWith(' ') ? '' : ' ';
                        const patterns = [
                            prefix + spacer + '"' + originalValue + '"',
                            prefix + spacer + "'" + originalValue + "'",
                            prefix + spacer + originalValue
                        ];
                        for (const pattern of patterns) {
                            if (content.includes(pattern)) {
                                content = content.replace(pattern, '');
                                changed = true;
                                break;
                            }
                        }
                    }
                    localStorage.removeItem(storageKey);
                } else if (originalValue && newValue !== originalValue) {
                    // Значение изменилось — заменяем
                    // Пробуем разные форматы и сохраняем тот же формат
                    const spacer = prefix.endsWith(' ') ? '' : ' ';
                    const patterns = [
                        { search: prefix + spacer + '"' + originalValue + '"', replace: prefix + spacer + '"' + newValue + '"' },
                        { search: prefix + spacer + "'" + originalValue + "'", replace: prefix + spacer + "'" + newValue + "'" },
                        { search: prefix + spacer + originalValue, replace: prefix + spacer + newValue }
                    ];
                    for (const p of patterns) {
                        if (content.includes(p.search)) {
                            content = content.replace(p.search, p.replace);
                            changed = true;
                            break;
                        }
                    }
                    localStorage.setItem(storageKey, newValue);
                } else if (!originalValue && newValue) {
                    // Первый раз — ищем placeholder в разных форматах
                    const placeholder = input.placeholder || 'example';
                    const spacer = prefix.endsWith(' ') ? '' : ' ';
                    const patterns = [
                        { search: prefix + spacer + '"' + placeholder + '"', replace: prefix + spacer + '"' + newValue + '"' },
                        { search: prefix + spacer + "'" + placeholder + "'", replace: prefix + spacer + "'" + newValue + "'" },
                        { search: prefix + spacer + placeholder, replace: prefix + spacer + newValue }
                    ];
                    for (const p of patterns) {
                        if (content.includes(p.search)) {
                            content = content.replace(p.search, p.replace);
                            changed = true;
                            break;
                        }
                    }
                    localStorage.setItem(storageKey, newValue);
                } else {
                    // Значение не изменилось — просто сохраняем
                    localStorage.setItem(storageKey, newValue);
                }
            });
            
            if (changed) {
                textarea.value = content;
                autoResizeTextarea(textarea);
                saveToLocalStorage(textarea.dataset.itemId, content);
                saveToUndoStack();
            }
            
            hideDynamicInputModal();
        }
        
        // Показ старой модалки keyword (fallback)
        function showKeywordModal(blockNumber) {
            closeAllModals();
            document.getElementById('keyword-modal').classList.add('open');
            document.getElementById('new-keyword-input').focus();
        }

        // --- МОДАЛКА УВЕДОМЛЕНИЙ (для "Нельзя удалить...") ---
        
        function showAlert(message, title = 'Уведомление') {
            closeAllModals();
            const modal = document.getElementById('alert-modal');
            const titleEl = document.getElementById('alert-title');
            const messageEl = document.getElementById('alert-message');
            
            if (titleEl) titleEl.textContent = title;
            if (messageEl) messageEl.textContent = message;
            if (modal) modal.classList.add('open');
        }
        
        function hideAlert() {
            const modal = document.getElementById('alert-modal');
            if (modal) modal.classList.remove('open');
        }

        /**
         * Показывает модальное окно сброса
         */
        function showResetModal() {
            closeAllModals();
            document.getElementById('reset-modal').classList.add('open');
        }

        /**
         * Скрывает модальное окно сброса
         */
        function hideResetModal() {
            document.getElementById('reset-modal').classList.remove('open');
        }
        
        // --- МОДАЛЬНОЕ ОКНО ПОДТВЕРЖДЕНИЯ ИМПОРТА ---
        let importConfirmResolve = null;
        
        function showImportConfirm(message) {
            return new Promise((resolve) => {
                importConfirmResolve = resolve;
                const modal = document.getElementById('import-confirm-modal');
                const messageEl = document.getElementById('import-confirm-message');
                if (messageEl) messageEl.textContent = message;
                if (modal) modal.classList.add('open');
            });
        }
        
        function hideImportConfirm(result) {
            const modal = document.getElementById('import-confirm-modal');
            if (modal) modal.classList.remove('open');
            if (importConfirmResolve) {
                importConfirmResolve(result);
                importConfirmResolve = null;
            }
        }
        
        // --- МОДАЛЬНОЕ ОКНО НАСТРОЕК ---
        let versionClickCount = 0;
        let versionClickTimer = null;
        
        function showSettingsModal() {
            closeAllModals();
            const modal = document.getElementById('settings-modal');
            const settings = getSettings();
            
            // Устанавливаем состояние кнопок автообновлений
            updateAutoUpdateButtons(settings.autoUpdate);
            
            // Устанавливаем активную тему
            updateThemeButtons(settings.theme);
            
            // Устанавливаем версию
            const versionSpan = document.getElementById('settings-version');
            if (versionSpan && window.__TAURI__) {
                window.__TAURI__.core.invoke('plugin:app|version').then(v => {
                    versionSpan.textContent = v;
                }).catch(() => {
                    versionSpan.textContent = '3.5.8';
                });
            }
            
            modal?.classList.add('open');
        }
        
        function hideSettingsModal() {
            document.getElementById('settings-modal')?.classList.remove('open');
        }
        
        function updateAutoUpdateButtons(enabled) {
            document.querySelectorAll('.auto-update-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.getElementById(enabled ? 'auto-update-on' : 'auto-update-off');
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }
        
        function updateThemeButtons(activeTheme) {
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.getElementById(`theme-${activeTheme}`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }
        
        function setTheme(theme) {
            const settings = getSettings();
            settings.theme = theme;
            saveSettings(settings);
            updateThemeButtons(theme);
            applyTheme(theme);
        }
        
        function applyTheme(theme) {
            const body = document.body;
            
            if (theme === 'dark') {
                body.classList.add('dark');
            } else if (theme === 'light') {
                body.classList.remove('dark');
            } else {
                // Auto - следуем системной теме
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                if (prefersDark) {
                    body.classList.add('dark');
                } else {
                    body.classList.remove('dark');
                }
            }
        }
        
        // Слушатель изменения системной темы
        function initThemeListener() {
            const settings = getSettings();
            applyTheme(settings.theme);
            
            // Слушаем изменения системной темы для auto режима
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                const currentSettings = getSettings();
                if (currentSettings.theme === 'auto') {
                    if (e.matches) {
                        document.body.classList.add('dark');
                    } else {
                        document.body.classList.remove('dark');
                    }
                }
            });
        }
        
        function toggleAutoUpdate(enabled) {
            const settings = getSettings();
            settings.autoUpdate = enabled;
            saveSettings(settings);
        }
        
        function handleVersionClick() {
            versionClickCount++;
            
            if (versionClickTimer) {
                clearTimeout(versionClickTimer);
            }
            
            versionClickTimer = setTimeout(() => {
                versionClickCount = 0;
            }, 500);
            
            if (versionClickCount >= 3) {
                versionClickCount = 0;
                isAdminMode = !isAdminMode;
                
                // Показываем уведомление
                const message = isAdminMode ? 'Режим администратора включён' : 'Режим администратора выключен';
                showToast(message);
                
                // Если выключили админ режим - выключаем и режим редактирования
                if (!isAdminMode && isEditMode) {
                    isEditMode = false;
                    loadPrompts();
                }
                
                hideSettingsModal();
            }
        }
        
        async function importConfig() {
            const input = document.getElementById('import-file-input');
            input.click();
        }
        
        async function handleImportFile(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            
            let importedCount = 0;
            let lastTabId = null;
            const tabs = getAllTabs();
            const conflicts = [];
            
            // Собираем все вкладки из всех файлов
            const allImportedTabs = {};
            
            for (const file of files) {
                try {
                    const text = await file.text();
                    const config = JSON.parse(text);
                    
                    if (config.tab) {
                        const tabId = config.tab.id || `imported-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                        config.tab.id = tabId;
                        allImportedTabs[tabId] = config.tab;
                        if (tabs[tabId]) {
                            conflicts.push(tabs[tabId].name);
                        }
                    } else if (config.tabs) {
                        Object.entries(config.tabs).forEach(([id, tab]) => {
                            allImportedTabs[id] = tab;
                            if (tabs[id]) {
                                conflicts.push(tabs[id].name);
                            }
                        });
                    }
                } catch (e) {
                    console.error(`Error parsing file ${file.name}:`, e);
                }
            }
            
            if (Object.keys(allImportedTabs).length === 0) {
                showToast('Не найдено вкладок для импорта');
                event.target.value = '';
                return;
            }
            
            // Если есть конфликты - спрашиваем
            if (conflicts.length > 0) {
                const uniqueConflicts = [...new Set(conflicts)];
                const choice = await showImportConfirm(`Следующие вкладки будут перезаписаны: ${uniqueConflicts.join(', ')}`);
                if (!choice) {
                    event.target.value = '';
                    return;
                }
            }
            
            // Сливаем вкладки
            const mergedTabs = { ...tabs, ...allImportedTabs };
            saveAllTabs(mergedTabs);
            
            // Переключаемся на первую импортированную
            const firstImported = Object.keys(allImportedTabs)[0];
            switchToTab(firstImported || 'default');
            
            const count = Object.keys(allImportedTabs).length;
            showToast(`Импортировано вкладок: ${count}`);
            
            // Сбрасываем input
            event.target.value = '';
        }

        /**
         * Сбрасывает все данные приложения и перезагружает
         */
        async function confirmReset() {
            try {
                // Очищаем все возможные ключи localStorage (включая старые версии)
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                localStorage.removeItem(LOCAL_STORAGE_KEY_TASK4);
                localStorage.removeItem(LANGUAGE_STORAGE_KEY);
                localStorage.removeItem(TAB_STORAGE_KEY);
                localStorage.removeItem(TABS_STORAGE_KEY);
                localStorage.removeItem(SETTINGS_STORAGE_KEY);
                localStorage.removeItem('claude-ai-prompts-data-v2');
                localStorage.removeItem('claude-ai-prompts-language-v2');
                
                // Очищаем весь localStorage связанный с приложением
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('claude-ai-prompts') || key.startsWith('ai-prompts-manager'))) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));
                
                // Вызываем Rust-команду для удаления папки приложения
                if (window.__TAURI__ && window.__TAURI__.core) {
                    await window.__TAURI__.core.invoke('reset_app_data');
                }
                
                // Перезагружаем приложение
                location.reload();
            } catch (e) {
                console.error('Ошибка при сбросе:', e);
                // Всё равно перезагружаем
                location.reload();
            }
        }

        /**
         * Показывает всплывающее уведомление.
         */
        function showToast(customText) {
            const toast = document.getElementById('toast');
            const textSpan = document.getElementById('toast-text');
            if (customText && textSpan) {
                textSpan.textContent = customText;
            } else if (textSpan) {
                textSpan.textContent = 'Скопировано в буфер';
            }
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // --- АВТООБНОВЛЕНИЕ ---
        let lastUpdateCheck = null; // Результат последней проверки
        
        async function checkForUpdates(showModal = false) {
            const btn = document.getElementById('update-check-btn');
            
            // Добавляем анимацию проверки
            if (btn) btn.classList.add('checking');
            
            // Небольшая задержка чтобы анимация была видна
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // Получаем текущую версию
            let currentVersion = 'dev';
            
            // Проверяем, что мы в Tauri
            if (window.__TAURI__) {
                try {
                    if (window.__TAURI__.core && window.__TAURI__.core.invoke) {
                        currentVersion = await window.__TAURI__.core.invoke('plugin:app|version');
                    } else if (window.__TAURI__.app && window.__TAURI__.app.getVersion) {
                        currentVersion = await window.__TAURI__.app.getVersion();
                    }
                } catch (e) {
                    console.log('Could not get version:', e);
                }
                
                // Проверяем обновления через updater
                if (window.__TAURI__.updater) {
                    try {
                        const { check } = window.__TAURI__.updater;
                        const update = await check();
                        
                        if (btn) btn.classList.remove('checking');
                        
                        if (update?.available) {
                            lastUpdateCheck = { available: true, version: update.version, body: update.body || '' };
                            if (showModal) {
                                showUpdateModalAvailable(update.version, update.body);
                            }
                            return lastUpdateCheck;
                        } else {
                            lastUpdateCheck = { available: false, version: currentVersion };
                            if (showModal) {
                                showUpdateModalLatest(currentVersion);
                            }
                            return lastUpdateCheck;
                        }
                    } catch (e) {
                        console.log('Update check failed:', e);
                    }
                }
            }
            
            // Fallback - показываем текущую версию
            if (btn) btn.classList.remove('checking');
            lastUpdateCheck = { available: false, version: currentVersion };
            if (showModal) {
                showUpdateModalLatest(currentVersion);
            }
            return lastUpdateCheck;
        }

        function showUpdateModalAvailable(newVersion, releaseNotes = '') {
            closeAllModals();
            const modal = document.getElementById('update-modal');
            const availableState = document.getElementById('update-available-state');
            const latestState = document.getElementById('update-latest-state');
            const versionSpan = document.getElementById('update-version');
            const installBtn = document.getElementById('install-update-btn');
            const notesContainer = document.getElementById('update-notes');
            const notesContent = document.getElementById('update-notes-content');
            
            if (versionSpan) versionSpan.textContent = newVersion;
            if (installBtn) {
                installBtn.disabled = false;
                installBtn.textContent = 'Обновить сейчас';
            }
            
            // Отображаем патчноуты если есть
            if (notesContainer && notesContent) {
                if (releaseNotes && releaseNotes.trim()) {
                    // Простое форматирование markdown-подобного текста
                    let formattedNotes = releaseNotes
                        .replace(/^### (.+)$/gm, '<strong class="block mt-2 mb-1">$1</strong>')
                        .replace(/^- (.+)$/gm, '<div class="flex gap-2"><span class="text-claude-accent">•</span><span>$1</span></div>')
                        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                        .replace(/`(.+?)`/g, '<code class="bg-gray-200 px-1 rounded text-xs">$1</code>')
                        .replace(/\n\n/g, '<br><br>')
                        .replace(/\n/g, '');
                    notesContent.innerHTML = formattedNotes;
                    notesContainer.classList.remove('hidden');
                } else {
                    notesContainer.classList.add('hidden');
                }
            }
            
            if (availableState) availableState.classList.remove('hidden');
            if (latestState) latestState.classList.add('hidden');
            if (modal) modal.classList.add('open');
        }

        function showUpdateModalLatest(currentVersion) {
            closeAllModals();
            const modal = document.getElementById('update-modal');
            const availableState = document.getElementById('update-available-state');
            const latestState = document.getElementById('update-latest-state');
            const versionSpan = document.getElementById('current-version');
            
            if (versionSpan) versionSpan.textContent = currentVersion;
            if (availableState) availableState.classList.add('hidden');
            if (latestState) latestState.classList.remove('hidden');
            if (modal) modal.classList.add('open');
        }

        // Для обратной совместимости
        function showUpdateModal(newVersion) {
            showUpdateModalAvailable(newVersion);
        }

        function hideUpdateModal() {
            const modal = document.getElementById('update-modal');
            if (modal) modal.classList.remove('open');
        }

        async function installUpdate() {
            if (!window.__TAURI__ || !window.__TAURI__.updater) return;
            
            const btn = document.getElementById('install-update-btn');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Загрузка...';
            }
            
            try {
                const { check } = window.__TAURI__.updater;
                const update = await check();
                
                if (update?.available) {
                    await update.downloadAndInstall();
                    // После установки перезапускаем приложение
                    const { relaunch } = window.__TAURI__.process;
                    await relaunch();
                }
            } catch (e) {
                console.error('Update failed:', e);
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Ошибка. Попробовать снова';
                }
            }
        }

        // Инициализация при загрузке содержимого DOM
        document.addEventListener('DOMContentLoaded', () => {
            // Глобальные слушатели для drag скроллбаров (один раз)
            document.addEventListener('mousemove', (e) => {
                if (!activeScrollbarData || !activeScrollbarData.isDragging) return;
                
                const { scrollable, scrollbar, thumb, startY, startScrollTop } = activeScrollbarData;
                const deltaY = e.clientY - startY;
                const scrollHeight = scrollable.scrollHeight;
                const clientHeight = scrollable.clientHeight;
                const trackHeight = scrollbar.clientHeight;
                const thumbHeight = Math.max(30, (clientHeight / scrollHeight) * trackHeight);
                const maxThumbTop = trackHeight - thumbHeight;
                const scrollRatio = (scrollHeight - clientHeight) / maxThumbTop;
                
                scrollable.scrollTop = startScrollTop + deltaY * scrollRatio;
            });
            
            document.addEventListener('mouseup', () => {
                if (activeScrollbarData && activeScrollbarData.isDragging) {
                    activeScrollbarData.isDragging = false;
                    activeScrollbarData.thumb.classList.remove('dragging');
                    activeScrollbarData.scrollbar.classList.remove('active');
                }
            });

            // Отслеживаем где началось нажатие мыши
            let mouseDownInsideTextarea = false;
            document.addEventListener('mousedown', (e) => {
                if (currentEditingCard) {
                    const textarea = currentEditingCard.querySelector('.textarea-content');
                    mouseDownInsideTextarea = textarea && textarea.contains(e.target);
                }
                
                // Также проверяем все input/textarea поля для предотвращения закрытия модалок при выделении текста
                const inputField = e.target.closest('input, textarea');
                if (inputField) {
                    mouseDownInsideTextarea = true;
                }
            });

            // Глобальный слушатель для закрытия редактирования при клике вне textarea
            document.addEventListener('click', (e) => {
                // Если mousedown был внутри любого текстового поля - не закрываем ничего
                if (mouseDownInsideTextarea) {
                    mouseDownInsideTextarea = false;
                    return;
                }
                
                if (currentEditingCard && currentDisableEditing) {
                    const textarea = currentEditingCard.querySelector('.textarea-content');
                    const editBtn = currentEditingCard.querySelector('.edit-button');
                    // Закрываем только если mousedown был снаружи textarea
                    if (textarea && editBtn && !textarea.contains(e.target) && !editBtn.contains(e.target)) {
                        currentDisableEditing();
                    }
                }
                mouseDownInsideTextarea = false;
                
                // Возврат панели инструментов на основную при клике вне инструкции
                const instructionTools = document.getElementById('instruction-tools');
                if (instructionTools && !instructionTools.classList.contains('hidden')) {
                    const isInstructionInput = e.target.closest('.instruction-input');
                    const isInstructionTools = e.target.closest('#instruction-tools');
                    if (!isInstructionInput && !isInstructionTools) {
                        showPromptTools();
                    }
                }
            });

            // Асинхронная инициализация
            (async () => {
                // Инициализация темы
                initThemeListener();
                
                await initializePersistence(); // Сначала проверка версии и сброс при обновлении
                initializeDefaultTabs(); // Потом инициализируем дефолтные вкладки если их нет
                loadPrompts(); // Загружаем промпты после инициализации вкладок
                initTabSelector();
                initLanguageSelector();
                
                // Обработчики модальных окон вкладок
                document.getElementById('confirm-add-tab-btn')?.addEventListener('click', () => {
                    const name = document.getElementById('new-tab-name')?.value?.trim();
                    if (!name) {
                        alert('Введите название вкладки');
                        return;
                    }
                    const newTabId = createNewTab(name);
                    hideAddTabModal();
                    window.switchToTab?.(newTabId);
                    // Включаем режим редактирования для новой вкладки
                    if (isAdminMode) {
                        isEditMode = true;
                        toggleEditToolbar(true);
                        loadPrompts();
                    }
                });
                
                document.getElementById('confirm-rename-tab-btn')?.addEventListener('click', () => {
                    const tabId = document.getElementById('rename-tab-id')?.value;
                    const name = document.getElementById('rename-tab-name')?.value?.trim();
                    if (!name) {
                        alert('Введите название вкладки');
                        return;
                    }
                    updateTab(tabId, { name });
                    hideRenameTabModal();
                    window.updateTabSelectorUI?.();
                });
                
                document.getElementById('confirm-delete-tab-btn')?.addEventListener('click', () => {
                    const tabId = document.getElementById('delete-tab-id')?.value;
                    if (currentTab === tabId) {
                        window.switchToTab?.('default');
                    }
                    deleteTab(tabId);
                    hideDeleteTabModal();
                    window.updateTabSelectorUI?.();
                });
                
                // Enter в полях ввода
                document.getElementById('new-tab-name')?.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') document.getElementById('confirm-add-tab-btn')?.click();
                });
                document.getElementById('rename-tab-name')?.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') document.getElementById('confirm-rename-tab-btn')?.click();
                });
                
                // Инициализация Undo/Redo
                // Сохраняем начальное состояние после полной отрисовки
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        saveToUndoStack();
                    });
                });
            })();
            
            // Обработчики кнопок Undo/Redo
            document.getElementById('undo-btn').addEventListener('click', undo);
            document.getElementById('redo-btn').addEventListener('click', redo);
            
            // --- Обработчики панели инструментов редактирования ---
            
            // Названия форм языка для меню
            const LANG_FORM_LABELS = {
                name: 'название языка',
                genitive: 'родительный',
                prepositional: 'предложный',
                adjective: 'прилагательное',
                adjectivePlural: 'мн. число',
                segment: 'сегмент',
                segmentAudience: 'аудитория'
            };
            
            // Генерирует меню языковых форм для текущего языка
            function updateLangMenu() {
                const langMenu = document.getElementById('lang-insert-menu');
                if (!langMenu) return;
                
                const lang = LANGUAGES[currentLanguage];
                if (!lang) return;
                
                let html = '<div class="py-1">';
                
                for (const [key, label] of Object.entries(LANG_FORM_LABELS)) {
                    const value = lang[key];
                    if (value) {
                        html += `<div class="lang-insert-option px-3 py-2 text-xs hover:bg-gray-100 cursor-pointer flex justify-between items-center" data-form="${key}">
                            <span class="text-claude-accent font-medium">${value}</span>
                            <span class="text-gray-400 text-[10px]">${label}</span>
                        </div>`;
                    }
                }
                
                html += '</div>';
                langMenu.innerHTML = html;
                
                // Переподключаем обработчики
                langMenu.querySelectorAll('.lang-insert-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const form = option.dataset.form;
                        const value = LANGUAGES[currentLanguage][form];
                        if (value) {
                            insertTextAtCursor(value);
                        }
                        langMenu.classList.add('hidden');
                    });
                });
            }
            
            // Кнопка вставки языкового блока
            const langBtn = document.getElementById('insert-lang-btn');
            const langMenu = document.getElementById('lang-insert-menu');
            if (langBtn && langMenu) {
                langBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    updateLangMenu(); // Обновляем меню перед показом
                    langMenu.classList.toggle('hidden');
                });
            }
            
            // Кнопка вставки UTF блока кодировки
            const utfBtn = document.getElementById('insert-utf-btn');
            if (utfBtn) {
                utfBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const utfBlock = LANGUAGES[currentLanguage]?.utfBlock;
                    if (utfBlock) {
                        insertTextAtCursor(utfBlock);
                    }
                });
            }
            
            // Закрытие меню при клике вне них
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#insert-lang-btn') && !e.target.closest('#lang-insert-menu')) {
                    document.getElementById('lang-insert-menu')?.classList.add('hidden');
                }
                if (!e.target.closest('#select-icon-btn') && !e.target.closest('#icon-select-menu')) {
                    document.getElementById('icon-select-menu')?.classList.add('hidden');
                }
            });
            
            // Кнопка выбора иконки для инструкции
            const iconBtn = document.getElementById('select-icon-btn');
            const iconMenu = document.getElementById('icon-select-menu');
            if (iconBtn && iconMenu) {
                iconBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    iconMenu.classList.toggle('hidden');
                });
                
                iconMenu.querySelectorAll('.icon-select-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const iconType = option.dataset.icon;
                        // Используем сохранённый активный блок инструкции
                        if (activeInstructionBlock) {
                            updateInstructionIcon(activeInstructionBlock, iconType);
                        }
                        iconMenu.classList.add('hidden');
                    });
                });
            }
            
            // Кнопка "Окно ввода" для настройки полей
            document.getElementById('create-replace-modal-btn')?.addEventListener('click', () => {
                if (activeInstructionBlock) {
                    showInputConstructorModal(activeInstructionBlock);
                }
            });
            
            // Обработчики конструктора полей ввода
            document.getElementById('add-constructor-field-btn')?.addEventListener('click', () => {
                addConstructorFieldElement();
            });
            
            document.getElementById('save-constructor-btn')?.addEventListener('click', () => {
                saveConstructorFields();
            });
            
            // Закрытие конструктора при клике на overlay
            document.getElementById('input-constructor-modal')?.addEventListener('mousedown', (e) => {
                if (e.target.id === 'input-constructor-modal') {
                    hideInputConstructorModal();
                }
            });
            
            // Обработчики динамической модалки ввода
            document.getElementById('apply-dynamic-input-btn')?.addEventListener('click', () => {
                applyDynamicInput();
            });
            
            // Закрытие динамической модалки при клике на overlay
            document.getElementById('dynamic-input-modal')?.addEventListener('mousedown', (e) => {
                if (e.target.id === 'dynamic-input-modal') {
                    hideDynamicInputModal();
                }
            });
            
            // Кнопка выхода из режима редактирования
            document.getElementById('exit-edit-mode-btn')?.addEventListener('click', () => {
                // Если в режиме reorder - сначала сохраняем порядок
                if (isReorderMode) {
                    const container = document.getElementById('cards-container');
                    if (container) {
                        saveBlocksOrder();
                    }
                    isReorderMode = false;
                }
                isEditMode = false;
                toggleEditToolbar(false);
                loadPrompts();
            });
            
            // Кнопка изменения порядка блоков
            document.getElementById('reorder-blocks-btn')?.addEventListener('click', toggleReorderMode);
            
            // Создаём главный кастомный скроллбар
            const scrollContainer = document.getElementById('scroll-container');
            const mainScrollbar = document.createElement('div');
            mainScrollbar.className = 'main-scrollbar';
            mainScrollbar.innerHTML = '<div class="main-scrollbar-thumb"></div>';
            document.body.appendChild(mainScrollbar);
            
            // Инициализация главного скроллбара
            initCustomScrollbar(scrollContainer, mainScrollbar);
            
            // Кнопка "Наверх" скроллит контейнер, а не окно
            document.getElementById('scroll-top-btn').addEventListener('click', () => {
                document.getElementById('scroll-container').scrollTo({top: 0, behavior: 'smooth'});
            });
            
            // Кнопка сброса
            document.getElementById('reset-btn').addEventListener('click', showResetModal);
            
            // Обработчик подтверждения сброса
            document.getElementById('confirm-reset-btn').addEventListener('click', confirmReset);
            
            // Закрытие модального окна сброса по клику на оверлей
            document.getElementById('reset-modal').addEventListener('click', (event) => {
                if (event.target.id === 'reset-modal') {
                    hideResetModal();
                }
            });
            
            // Обработчики модального окна подтверждения импорта
            document.getElementById('import-confirm-btn')?.addEventListener('click', () => hideImportConfirm(true));
            document.getElementById('import-cancel-btn')?.addEventListener('click', () => hideImportConfirm(false));
            document.getElementById('import-confirm-modal')?.addEventListener('click', (event) => {
                if (event.target.id === 'import-confirm-modal') {
                    hideImportConfirm(false);
                }
            });
            
            // Обработчики модалки уведомлений
            document.getElementById('alert-ok-btn')?.addEventListener('click', hideAlert);
            document.getElementById('alert-modal')?.addEventListener('click', (event) => {
                if (event.target.id === 'alert-modal') {
                    hideAlert();
                }
            });
            
            // Обработчик кнопки проверки обновлений (иконка в хедере)
            const updateCheckBtn = document.getElementById('update-check-btn');
            if (updateCheckBtn) {
                updateCheckBtn.addEventListener('click', () => {
                    checkForUpdates(true); // true = показать модальное окно
                });
            }
            
            // Обработчики модального окна обновления
            const updateModal = document.getElementById('update-modal');
            const installBtn = document.getElementById('install-update-btn');
            const laterBtn = document.getElementById('update-later-btn');
            const okBtn = document.getElementById('update-ok-btn');
            
            if (installBtn) {
                installBtn.addEventListener('click', installUpdate);
            }
            if (laterBtn) {
                laterBtn.addEventListener('click', hideUpdateModal);
            }
            if (okBtn) {
                okBtn.addEventListener('click', hideUpdateModal);
            }
            if (updateModal) {
                updateModal.addEventListener('click', (event) => {
                    if (event.target.id === 'update-modal') {
                        hideUpdateModal();
                    }
                });
            }
            
            // Фоновая проверка обновлений через 1 секунду
            // Показывает окно только если есть обновление и включено автообновление
            setTimeout(async () => {
                const settings = getSettings();
                if (settings.autoUpdate) {
                    const result = await checkForUpdates(false);
                    if (result?.available) {
                        showUpdateModalAvailable(result.version, result.body);
                    }
                }
            }, 1000);
            
            // --- ОБРАБОТЧИКИ НАСТРОЕК ---
            
            // Кнопка настроек
            document.getElementById('settings-btn')?.addEventListener('click', showSettingsModal);
            
            // Переключатель автообновлений
            // Кнопки автообновления
            document.getElementById('auto-update-off')?.addEventListener('click', () => {
                toggleAutoUpdate(false);
                updateAutoUpdateButtons(false);
            });
            document.getElementById('auto-update-on')?.addEventListener('click', () => {
                toggleAutoUpdate(true);
                updateAutoUpdateButtons(true);
            });
            
            // Кнопки выбора темы
            document.getElementById('theme-light')?.addEventListener('click', () => setTheme('light'));
            document.getElementById('theme-auto')?.addEventListener('click', () => setTheme('auto'));
            document.getElementById('theme-dark')?.addEventListener('click', () => setTheme('dark'));
            
            // Импорт конфигурации (input для выбора файла)
            document.getElementById('import-file-input')?.addEventListener('change', handleImportFile);
            
            // Тройной клик по версии
            document.getElementById('version-label')?.addEventListener('click', handleVersionClick);
            
            // Закрытие модальных окон по mousedown на оверлей (не click, чтобы выделение текста работало)
            document.getElementById('settings-modal')?.addEventListener('mousedown', (event) => {
                if (event.target.id === 'settings-modal') {
                    hideSettingsModal();
                }
            });
            
            document.getElementById('add-tab-modal')?.addEventListener('mousedown', (event) => {
                if (event.target.id === 'add-tab-modal') {
                    hideAddTabModal();
                }
            });
            
            document.getElementById('rename-tab-modal')?.addEventListener('mousedown', (event) => {
                if (event.target.id === 'rename-tab-modal') {
                    hideRenameTabModal();
                }
            });
            
            document.getElementById('delete-tab-modal')?.addEventListener('mousedown', (event) => {
                if (event.target.id === 'delete-tab-modal') {
                    hideDeleteTabModal();
                }
            });
            
            document.getElementById('reset-modal')?.addEventListener('mousedown', (event) => {
                if (event.target.id === 'reset-modal') {
                    hideResetModal();
                }
            });
            
            document.getElementById('input-constructor-modal')?.addEventListener('mousedown', (event) => {
                if (event.target.id === 'input-constructor-modal') {
                    hideInputConstructorModal();
                }
            });
            
            document.getElementById('dynamic-input-modal')?.addEventListener('mousedown', (event) => {
                if (event.target.id === 'dynamic-input-modal') {
                    hideDynamicInputModal();
                }
            });
        });

    </script>
</body>
</html>