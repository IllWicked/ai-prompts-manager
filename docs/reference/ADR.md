# Architecture Decision Records (ADR)

[← Назад к INDEX](../INDEX.md)

Записи архитектурных решений — почему проект устроен именно так.

---

## ADR-001: Ограничение в 3 таба Claude

**Дата:** Январь 2026  
**Статус:** Принято

### Контекст

При разработке интеграции с Claude возник вопрос: сколько независимых чатов поддерживать?

### Решение

Ограничить количество Claude WebView до **3 штук**.

### Причины

| Фактор | Обоснование |
|--------|-------------|
| **Память** | Каждый WebView занимает ~200-500MB RAM |
| **Производительность** | Больше WebView = медленнее resize окна |
| **UX** | 3 чата достаточно для большинства сценариев |
| **Простота UI** | Легко представить визуально (кнопки 1/2/3) |

### Альтернативы

1. **Неограниченное количество** — отвергнуто из-за memory overhead
2. **Динамическое создание** — усложняет UI и управление состоянием
3. **Один таб** — недостаточно для workflow с несколькими контекстами

### Последствия

- Workaround: использовать флаг N (New Chat) для создания чатов внутри одного таба
- Константа `MAX_CLAUDE_TABS = 3` захардкожена в Rust

---

## ADR-002: localStorage вместо IndexedDB

**Дата:** Декабрь 2025  
**Статус:** Принято

### Контекст

Где хранить данные вкладок, workflow, настройки?

### Решение

Использовать **localStorage** браузера (WebView).

### Причины

| За localStorage | Против IndexedDB |
|-----------------|------------------|
| Синхронный API — проще код | Async API — сложнее обработка |
| JSON.parse/stringify — просто | Курсоры, транзакции — сложно |
| Достаточно для наших данных (~1-2MB) | Overkill для простых структур |
| Один вызов — одна операция | Нужна обёртка для удобства |

### Ограничения

- Лимит ~5-10MB (зависит от браузера)
- Нет индексов для поиска
- Блокирует main thread при больших данных

### Митигация

- Мониторинг использования (см. LIMITATIONS.md)
- Экспорт старых вкладок при приближении к лимиту
- Workflow-данные в отдельных ключах (`workflow-{tabId}`)

### Когда пересмотреть

Если данные превысят 3MB или появится необходимость в offline-first режиме.

---

## ADR-003: CDP вместо WebMessageReceived

**Дата:** Январь 2026  
**Статус:** Принято

### Контекст

Как получить результат async JavaScript из Claude WebView?

### Варианты

1. **WebMessageReceived** — `chrome.webview.postMessage()` + listener в Rust
2. **Chrome DevTools Protocol (CDP)** — `Runtime.evaluate` с `awaitPromise: true`

### Решение

Использовать **CDP (Runtime.evaluate)**.

### Причины

| CDP | WebMessageReceived |
|-----|-------------------|
| JS код не знает о транспорте | Нужно модифицировать каждый скрипт |
| Один запрос = один ответ | Нужна система ID для матчинга |
| Тестируется в обычном браузере | Только в WebView2 |
| awaitPromise встроен | Нужно вручную ждать Promise |

### Реализация

```rust
let cdp_params = r#"{
    "expression": "(async () => { ... })()",
    "awaitPromise": true,
    "returnByValue": true
}"#;

core.CallDevToolsProtocolMethod("Runtime.evaluate", cdp_params, &handler);
```

### Риски

- CDP — внутренний протокол, теоретически может измениться
- `Runtime.evaluate` стабилен годами, риск минимален

---

## ADR-004: Централизованные селекторы Claude

**Дата:** Январь 2026  
**Статус:** Принято (обновлено v4.2.0)

### Контекст

Claude.ai периодически обновляет разметку. Где хранить селекторы элементов?

### Варианты

1. **В JS (config.js)** — легко редактировать, но нужен rebuild frontend
2. **В Rust (main.rs) inline** — единый источник правды, но сложно редактировать
3. **В JSON файле** — гибко, легко редактировать, загружается через `include_str!()`

### Решение

~~Хранить все селекторы в main.rs~~ → **v4.2.0:** Вынести селекторы в `src-tauri/scripts/selectors.json`.

Файл загружается в Rust через `include_str!()` и передаётся в WebView через `window.__SEL__`.

### Причины

- **Единый источник** — один файл для всех селекторов
- **Лёгкое редактирование** — JSON проще редактировать чем Rust-строки
- **Fallback-массивы** — поддержка альтернативных селекторов
- **Структурированность** — категории (generation, input, navigation, project, ui)

### Реализация

```
src-tauri/scripts/selectors.json    ← Единый источник
        ↓
    include_str!()
        ↓
const CLAUDE_SELECTORS_JSON         ← Константа в main.rs
        ↓
get_claude_init_script()
        ↓
window.__SEL__                      ← Доступно в Claude WebView
```

```json
// selectors.json (упрощённо)
{
  "generation": {
    "stopButton": ["button[aria-label='Stop Response']", "..."],
    "streamingIndicator": "[data-is-streaming='true']"
  },
  "input": {
    "proseMirror": ".ProseMirror",
    "sendButton": ["button[aria-label='Send message']", "..."]
  }
}
```

### Использование в JS

```javascript
// Получение селектора по пути
function __getSel__(path) {
    return path.split('.').reduce((obj, key) => obj?.[key], window.__SEL__);
}

// Поиск элемента с fallback
function __findEl__(path) {
    const sel = __getSel__(path);
    if (Array.isArray(sel)) {
        for (const s of sel) {
            const el = document.querySelector(s);
            if (el) return el;
        }
        return null;
    }
    return document.querySelector(sel);
}
```

### Изменение селекторов

При обновлении Claude.ai редактировать **только** `src-tauri/scripts/selectors.json`.

→ См. [TROUBLESHOOTING-SELECTORS.md](TROUBLESHOOTING-SELECTORS.md)

---

## ADR-005: DAG для Workflow connections

**Дата:** Январь 2026  
**Статус:** Принято

### Контекст

Как моделировать связи между блоками в Workflow?

### Решение

**Directed Acyclic Graph (DAG)** — направленный ациклический граф.

### Причины

| Требование | Решение |
|------------|---------|
| Порядок выполнения | Направленные рёбра (A → B) |
| Нет бесконечных циклов | Проверка `wouldCreateCycle()` при добавлении |
| Множественные входы | Блок может иметь несколько входящих связей |
| Визуализация | Bezier-кривые между портами |

### Проверка циклов

```javascript
function wouldCreateCycle(fromBlockId, toBlockId) {
    // DFS от toBlockId
    const visited = new Set();
    const stack = [toBlockId];
    
    while (stack.length > 0) {
        const current = stack.pop();
        if (current === fromBlockId) return true; // Цикл!
        if (visited.has(current)) continue;
        visited.add(current);
        
        connections
            .filter(c => c.from === current)
            .forEach(c => stack.push(c.to));
    }
    return false;
}
```

### Ограничения

- Нет поддержки циклов (by design)
- Нет условных переходов (A → B если X, иначе → C)

---

## ADR-006: Vanilla JS вместо React/Vue

**Дата:** Ноябрь 2025  
**Статус:** Принято

### Контекст

Какой frontend фреймворк использовать?

### Решение

**Vanilla JavaScript** с модульной структурой.

### Причины

| За Vanilla JS | Против React/Vue |
|---------------|------------------|
| Нет build step | Нужен bundler |
| Простая отладка | Source maps, HMR complexity |
| Быстрый старт | Boilerplate setup |
| Полный контроль | Фреймворк навязывает паттерны |
| Маленький размер | +100KB минимум для runtime |

### Структура

- 35 JS модулей в `dist/js/`
- Inline JS в `index.html` для DOM-зависимого кода
- `window.AppState` для shared state

### Когда пересмотреть

Если команда вырастет или появится необходимость в сложных UI-компонентах (таблицы, графики).

---

## ADR-007: Tauri 2.0 вместо Electron

**Дата:** Ноябрь 2025  
**Статус:** Принято

### Контекст

Какой фреймворк для desktop-приложения?

### Решение

**Tauri 2.0** с Rust backend.

### Причины

| Tauri | Electron |
|-------|----------|
| ~10MB установщик | ~150MB |
| Нативный WebView2 | Встроенный Chromium |
| Rust backend | Node.js backend |
| Меньше RAM | Больше RAM |
| Новый, активно развивается | Зрелый, стабильный |

### Ограничения

- Windows only (WebView2)
- Меньше документации чем у Electron
- Rust learning curve

### Последствия

- Быстрое приложение, маленький размер
- Нужно знать Rust для backend-логики
- Меньше ready-made плагинов

---

## ADR-008: Ручное тестирование вместо автотестов

**Дата:** Январь 2026  
**Статус:** Частично пересмотрено (см. ADR-009)

### Контекст

Нужна ли автоматизация тестирования для внутреннего проекта с одним разработчиком?

### Решение

Использовать **ручное тестирование** по чеклистам (см. [TESTING.md](../guides/TESTING.md)) для интеграционного и E2E тестирования.

### Причины

| За ручное тестирование | Против автотестов |
|------------------------|-------------------|
| Один разработчик — быстрая обратная связь | Overhead на написание и поддержку |
| UI-heavy приложение — сложно автоматизировать | WebView2 + Claude.ai = нестабильные селекторы |
| Быстрые релизы важнее coverage | E2E тесты ломаются при обновлениях Claude |
| Чеклист достаточен для scope проекта | Нет CI/CD инфраструктуры для тестов |

### Альтернативы

1. **Unit тесты для JS модулей** — ✅ реализовано в v4.2.0 (см. ADR-009)
2. **Unit тесты для Rust** — возможно в будущем для критичных функций
3. **Playwright для E2E** — отвергнуто (Claude.ai меняет разметку)

### Последствия

- Чеклист в [TESTING.md](../guides/TESTING.md) — основной инструмент для интеграционного тестирования
- Unit-тесты покрывают критичную бизнес-логику (см. ADR-009)
- Перед релизом — ручная проверка по списку

### Когда пересмотреть

- Критический баг в production, который поймал бы E2E автотест
- Стабилизация API Claude.ai (маловероятно)

---

## ADR-009: Unit-тесты для JavaScript модулей

**Дата:** Январь 2026  
**Статус:** Принято

### Контекст

После роста кодовой базы (35 JS модулей, ~290 функций) ручное тестирование стало недостаточным для отлова регрессий в критичных модулях.

### Решение

Внедрить **Jest unit-тесты** для изолированного тестирования JavaScript модулей.

### Причины

| За unit-тесты | Реализация |
|---------------|------------|
| Быстрая обратная связь | ~3.6 сек на 260 тестов |
| Отлов регрессий | Покрыты критичные модули |
| Документация поведения | Тесты описывают контракты функций |
| Рефакторинг без страха | Можно менять реализацию |

### Реализация

- **Инфраструктура:** Jest + jsdom
- **Покрытие:** 7 модулей, 265 тестов (260 passed, 5 skipped)
- **Модули:** storage.js, tabs.js, undo.js, connections.js, utils.js, export-import.js
- **Документация:** [tests/README.md](../../tests/README.md)

### Ограничения

- Тесты копируют функции (browser-style модули, не ES6)
- jsdom не поддерживает некоторые API (DOMMatrix, Storage quota)
- Coverage 0% (функции не импортируются)
- Tauri API не тестируется (требует E2E)

### Связанные документы

- [TESTING.md](../guides/TESTING.md) — Общее руководство
- [UNIT-TESTS-PLAN.md](../UNIT-TESTS-PLAN.md) — План тестирования
- [tests/README.md](../../tests/README.md) — Документация тестов

---

## ADR-010: Модульная архитектура Backend

**Дата:** Январь 2026  
**Статус:** Принято

### Контекст

Файл `main.rs` вырос до 2140 строк, что затрудняло:
- Навигацию по коду
- Понимание зависимостей между функциями
- Добавление новых команд
- Code review и отладку

### Решение

Разбить монолитный `main.rs` на **20 файлов** по функциональности:

```
src-tauri/src/
├── main.rs        (131 строк) — только setup
├── lib.rs         — реэкспорт
├── types.rs       — структуры данных
├── state.rs       — глобальные состояния
├── commands/      — 6 модулей с 45 командами
├── downloads/     — пути и настройки
├── utils/         — MIME, платформа, размеры
└── webview/       — скрипты и управление
```

### Причины

| Проблема | Решение |
|----------|---------|
| 2140 строк в одном файле | Макс. 611 строк в модуле |
| Неясные зависимости | Явные `use crate::...` |
| Сложно найти команду | Команды сгруппированы по доменам |
| Дублирование констант | Единое место в `utils/dimensions.rs` |
| Нет документации в коде | `///` комментарии в каждом модуле |

### Альтернативы

1. **Один большой файл** — отвергнуто, не масштабируется
2. **Разбить только commands** — недостаточно, утилиты тоже нужно выносить
3. **Workspace с несколькими crates** — overkill для текущего размера

### Последствия

**Плюсы:**
- Улучшена читаемость и навигация
- Проще добавлять новые команды
- Чёткое разделение ответственности
- Документация в коде

**Минусы:**
- Больше файлов для отслеживания
- Нужно следить за циклическими зависимостями
- Чуть больше boilerplate (`mod.rs`, реэкспорты)

### Структура модулей

| Модуль | Ответственность |
|--------|-----------------|
| `types` | Структуры данных (DTO) |
| `state` | Глобальные `static` переменные |
| `commands/*` | Tauri команды по доменам |
| `downloads` | Пути к файлам, настройки |
| `utils` | Утилиты без состояния |
| `webview` | JS скрипты, создание webview |

### Миграция команд

При добавлении новой команды:
1. Выбрать подходящий модуль в `commands/`
2. Добавить функцию с `#[tauri::command]`
3. Реэкспортировать в `commands/mod.rs`
4. Зарегистрировать в `main.rs`

→ См. [03-BACKEND.md](../03-BACKEND.md#добавление-новых-команд)

---

## Шаблон для новых ADR

```markdown
## ADR-XXX: [Название]

**Дата:** YYYY-MM  
**Статус:** Предложено | Принято | Отклонено | Устарело

### Контекст

[Описание проблемы или вопроса]

### Решение

[Принятое решение]

### Причины

[Почему это решение лучше альтернатив]

### Альтернативы

[Рассмотренные альтернативы]

### Последствия

[Что изменится, какие ограничения]
```

---

## Связанные документы

- [01-OVERVIEW.md](../01-OVERVIEW.md) — Архитектура
- [03-BACKEND.md](../03-BACKEND.md) — Tauri/Rust
- [04-CLAUDE.md](../04-CLAUDE.md) — Claude интеграция
